/* tslint:disable */
/* eslint-disable */
/**
 * Observer interaction
 * Explore the functionality of a Observer
 *
 * The version of the OpenAPI document: 1.0.0 - f20cfc7657a97641
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface BlockInfo
 */
export interface BlockInfo {
    /**
     * id of the block
     * @type {number}
     * @memberof BlockInfo
     */
    id: number;
    /**
     * time when the block got persisted
     * @type {string}
     * @memberof BlockInfo
     */
    createdAt: string;
    /**
     * time when the transaction was persisted in an imported blockchain
     * @type {string}
     * @memberof BlockInfo
     */
    imported?: string;
}
/**
 * 
 * @export
 * @interface Compression
 */
export interface Compression {
    /**
     * type of the compression
     * @type {string}
     * @memberof Compression
     */
    type: CompressionTypeEnum;
    /**
     * Json encoded information that are required for this kind of compression.
     * @type {string}
     * @memberof Compression
     */
    value?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum CompressionTypeEnum {
    Json = 'JSON',
    Proto = 'PROTO'
}

/**
 * 
 * @export
 * @interface ControllerManage
 */
export interface ControllerManage {
    /**
     * id that should be added to the controller list.
     * @type {Array<string>}
     * @memberof ControllerManage
     */
    add?: Array<string>;
    /**
     * id that should be removed from the controller list.
     * @type {Array<string>}
     * @memberof ControllerManage
     */
    remove?: Array<string>;
}
/**
 * 
 * @export
 * @interface DidDocument
 */
export interface DidDocument {
    /**
     * unique identifier of a did.
     * @type {string}
     * @memberof DidDocument
     */
    id: string;
    /**
     * unique identifiers of the controller.
     * @type {Array<string>}
     * @memberof DidDocument
     */
    controller: Array<string>;
    /**
     * array of keys that belong to the did document.
     * @type {Array<DidPublicKey>}
     * @memberof DidDocument
     */
    verificationMethod: Array<DidPublicKey>;
    /**
     * keys that are used for authentication.
     * @type {Array<string>}
     * @memberof DidDocument
     */
    authentication: Array<string>;
    /**
     * keys that are used for assertion.
     * @type {Array<string>}
     * @memberof DidDocument
     */
    assertionMethod: Array<string>;
    /**
     * keys that are used for modification.
     * @type {Array<string>}
     * @memberof DidDocument
     */
    modification: Array<string>;
    /**
     * services that are connected with this did.
     * @type {Array<DidService>}
     * @memberof DidDocument
     */
    service: Array<DidService>;
    /**
     * role of the did
     * @type {Array<string>}
     * @memberof DidDocument
     */
    role: Array<DidDocumentRoleEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum DidDocumentRoleEnum {
    Validator = 'validator',
    Gateway = 'gateway',
    Observer = 'observer',
    Client = 'client'
}

/**
 * 
 * @export
 * @interface DidDocumentMetaData
 */
export interface DidDocumentMetaData {
    /**
     * 
     * @type {string}
     * @memberof DidDocumentMetaData
     */
    updated: string;
    /**
     * 
     * @type {boolean}
     * @memberof DidDocumentMetaData
     */
    deactivated: boolean;
    /**
     * 
     * @type {string}
     * @memberof DidDocumentMetaData
     */
    nextUpdate: string;
    /**
     * 
     * @type {number}
     * @memberof DidDocumentMetaData
     */
    versionId: number;
    /**
     * 
     * @type {number}
     * @memberof DidDocumentMetaData
     */
    nextVersionId: number;
    /**
     * 
     * @type {string}
     * @memberof DidDocumentMetaData
     */
    created: string;
}
/**
 * 
 * @export
 * @interface DidPublicKey
 */
export interface DidPublicKey {
    /**
     * unique identifier of a key
     * @type {string}
     * @memberof DidPublicKey
     */
    id: string;
    /**
     * controller of the key
     * @type {string}
     * @memberof DidPublicKey
     */
    controller: string;
    /**
     * Type of the key
     * @type {string}
     * @memberof DidPublicKey
     */
    type: DidPublicKeyTypeEnum;
    /**
     * encoded key value
     * @type {PublicKeyJwkDto}
     * @memberof DidPublicKey
     */
    publicKeyJwk: PublicKeyJwkDto;
}

/**
    * @export
    * @enum {string}
    */
export enum DidPublicKeyTypeEnum {
    RsaVerificationKey2018 = 'RsaVerificationKey2018'
}

/**
 * 
 * @export
 * @interface DidService
 */
export interface DidService {
    /**
     * unique identifier of a service
     * @type {string}
     * @memberof DidService
     */
    id: string;
    /**
     * name of the service
     * @type {string}
     * @memberof DidService
     */
    type: string;
    /**
     * url to the service
     * @type {string}
     * @memberof DidService
     */
    endpoint: string;
}
/**
 * 
 * @export
 * @interface DidStructure
 */
export interface DidStructure {
    /**
     * unique identifier of a did
     * @type {string}
     * @memberof DidStructure
     */
    id: string;
    /**
     * 
     * @type {ControllerManage}
     * @memberof DidStructure
     */
    controller?: ControllerManage;
    /**
     * 
     * @type {RoleManage}
     * @memberof DidStructure
     */
    role?: RoleManage;
    /**
     * 
     * @type {VerificationMethod}
     * @memberof DidStructure
     */
    verificationMethod?: VerificationMethod;
    /**
     * 
     * @type {ServiceMange}
     * @memberof DidStructure
     */
    service?: ServiceMange;
    /**
     * 
     * @type {VerificationRelationshipManage}
     * @memberof DidStructure
     */
    authentication?: VerificationRelationshipManage;
    /**
     * 
     * @type {VerificationRelationshipManage}
     * @memberof DidStructure
     */
    assertionMethod?: VerificationRelationshipManage;
    /**
     * 
     * @type {VerificationRelationshipManage}
     * @memberof DidStructure
     */
    keyAgreement?: VerificationRelationshipManage;
    /**
     * 
     * @type {VerificationRelationshipManage}
     * @memberof DidStructure
     */
    modification?: VerificationRelationshipManage;
    /**
     * 
     * @type {VerificationRelationshipManage}
     * @memberof DidStructure
     */
    capabilityDelegation?: VerificationRelationshipManage;
    /**
     * 
     * @type {VerificationRelationshipManage}
     * @memberof DidStructure
     */
    capabilityInvocation?: VerificationRelationshipManage;
}
/**
 * 
 * @export
 * @interface DidTransaction
 */
export interface DidTransaction {
    /**
     * Signature of the hash.
     * @type {Array<SignatureDto>}
     * @memberof DidTransaction
     */
    signature: Array<SignatureDto>;
    /**
     * Blockinformation
     * @type {BlockInfo}
     * @memberof DidTransaction
     */
    block: BlockInfo;
    /**
     * Timestamp when the element was created.
     * @type {string}
     * @memberof DidTransaction
     */
    createdAt: string;
    /**
     * Values of the transaction
     * @type {DidStructure}
     * @memberof DidTransaction
     */
    values: DidStructure;
    /**
     * Signature of the hash.
     * @type {Array<SignatureDto>}
     * @memberof DidTransaction
     */
    didDocumentSignature: Array<SignatureDto>;
    /**
     * 
     * @type {string}
     * @memberof DidTransaction
     */
    id: string;
}
/**
 * 
 * @export
 * @interface DocResponse
 */
export interface DocResponse {
    /**
     * parsed did document
     * @type {DidDocument}
     * @memberof DocResponse
     */
    document: DidDocument;
    /**
     * signatures of the parsed document
     * @type {Array<SignatureDto>}
     * @memberof DocResponse
     */
    signatures: Array<SignatureDto>;
    /**
     * Metadata of the document
     * @type {DidDocumentMetaData}
     * @memberof DocResponse
     */
    metaData: DidDocumentMetaData;
}
/**
 * 
 * @export
 * @interface Hash
 */
export interface Hash {
    /**
     * Signature of the hash.
     * @type {Array<SignatureDto>}
     * @memberof Hash
     */
    signature: Array<SignatureDto>;
    /**
     * Blockinformation
     * @type {BlockInfo}
     * @memberof Hash
     */
    block: BlockInfo;
    /**
     * Hash of the file.
     * @type {string}
     * @memberof Hash
     */
    hash: string;
    /**
     * Used algorithm for the hash.
     * @type {string}
     * @memberof Hash
     */
    hashAlgorithm: string;
    /**
     * Timestamp when the hash was signed.
     * @type {string}
     * @memberof Hash
     */
    createdAt: string;
    /**
     * Timestamp when the hash was revoked.
     * @type {string}
     * @memberof Hash
     */
    revokedAt?: string;
}
/**
 * 
 * @export
 * @interface InviteNode
 */
export interface InviteNode {
    /**
     * id of the did
     * @type {string}
     * @memberof InviteNode
     */
    id: string;
    /**
     * Secret token
     * @type {string}
     * @memberof InviteNode
     */
    secret: string;
    /**
     * Url of the node endpoint
     * @type {string}
     * @memberof InviteNode
     */
    url: string;
}
/**
 * 
 * @export
 * @interface PublicKeyJwkDto
 */
export interface PublicKeyJwkDto {
    /**
     * How the key was meant to be used
     * @type {Array<string>}
     * @memberof PublicKeyJwkDto
     */
    key_ops?: Array<string>;
    /**
     * The family of cryptographic algorithms used with the key.
     * @type {string}
     * @memberof PublicKeyJwkDto
     */
    kty?: string;
    /**
     * The modulus for the RSA public key.
     * @type {string}
     * @memberof PublicKeyJwkDto
     */
    n?: string;
    /**
     * The exponent for the RSA public key.
     * @type {string}
     * @memberof PublicKeyJwkDto
     */
    e?: string;
    /**
     * The specific cryptographic algorithm used with the key.
     * @type {string}
     * @memberof PublicKeyJwkDto
     */
    alg?: string;
}
/**
 * 
 * @export
 * @interface RoleManage
 */
export interface RoleManage {
    /**
     * roles that should be added to the did
     * @type {Array<string>}
     * @memberof RoleManage
     */
    add?: Array<RoleManageAddEnum>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RoleManage
     */
    remove?: Array<string>;
}

/**
    * @export
    * @enum {string}
    */
export enum RoleManageAddEnum {
    Validator = 'validator',
    Gateway = 'gateway',
    Observer = 'observer',
    Client = 'client'
}

/**
 * 
 * @export
 * @interface ServiceMange
 */
export interface ServiceMange {
    /**
     * List of services that should be added to the did document.
     * @type {Array<DidService>}
     * @memberof ServiceMange
     */
    add?: Array<DidService>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ServiceMange
     */
    remove?: Array<string>;
}
/**
 * 
 * @export
 * @interface SignatureDto
 */
export interface SignatureDto {
    /**
     * Identifier of the issuer and the used key
     * @type {string}
     * @memberof SignatureDto
     */
    identifier: string;
    /**
     * The actual signature as a hex encoded string.
     * @type {string}
     * @memberof SignatureDto
     */
    signature: string;
}
/**
 * 
 * @export
 * @interface Template
 */
export interface Template {
    /**
     * Signature of the hash.
     * @type {Array<SignatureDto>}
     * @memberof Template
     */
    signature: Array<SignatureDto>;
    /**
     * Blockinformation
     * @type {BlockInfo}
     * @memberof Template
     */
    block: BlockInfo;
    /**
     * did of the template
     * @type {string}
     * @memberof Template
     */
    id: string;
    /**
     * information about the compression
     * @type {Compression}
     * @memberof Template
     */
    compression: Compression;
    /**
     * value of the template
     * @type {string}
     * @memberof Template
     */
    template: string;
    /**
     * schema of the input
     * @type {string}
     * @memberof Template
     */
    schema: string;
}
/**
 * 
 * @export
 * @interface VerificationMethod
 */
export interface VerificationMethod {
    /**
     * List of public keys that should be added to the did document.
     * @type {Array<DidPublicKey>}
     * @memberof VerificationMethod
     */
    add?: Array<DidPublicKey>;
    /**
     * 
     * @type {Array<string>}
     * @memberof VerificationMethod
     */
    remove?: Array<string>;
}
/**
 * 
 * @export
 * @interface VerificationRelationshipManage
 */
export interface VerificationRelationshipManage {
    /**
     * id that should be removed from the list
     * @type {Array<string>}
     * @memberof VerificationRelationshipManage
     */
    add?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof VerificationRelationshipManage
     */
    remove?: Array<string>;
}

/**
 * DefaultObserverApi - axios parameter creator
 * @export
 */
export const DefaultObserverApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promControllerIndex: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultObserverApi - functional programming interface
 * @export
 */
export const DefaultObserverApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultObserverApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promControllerIndex(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promControllerIndex(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultObserverApi - factory interface
 * @export
 */
export const DefaultObserverApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultObserverApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promControllerIndex(options?: any): AxiosPromise<void> {
            return localVarFp.promControllerIndex(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultObserverApi - object-oriented interface
 * @export
 * @class DefaultObserverApi
 * @extends {BaseAPI}
 */
export class DefaultObserverApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultObserverApi
     */
    public promControllerIndex(options?: any) {
        return DefaultObserverApiFp(this.configuration).promControllerIndex(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DidObserverApi - axios parameter creator
 * @export
 */
export const DidObserverApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns the genesis block to build the chain of trust
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerDidControllerGenesis: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/did/genesis`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the did document to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] return the did document that was present to 2021-09-26T18:18:36.854Z
         * @param {number} [versionId] return the did document with this version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerDidControllerGetDoc: async (id: string, versionTime?: string, versionId?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('observerDidControllerGetDoc', 'id', id)
            const localVarPath = `/did/{id}/doc`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (versionTime !== undefined) {
                localVarQueryParameter['versionTime'] = versionTime;
            }

            if (versionId !== undefined) {
                localVarQueryParameter['versionId'] = versionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the transaction to assemble a did document.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp like 2021-09-26T18:18:36.853Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerDidControllerGetTransactions: async (id: string, versionTime?: string, versionId?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('observerDidControllerGetTransactions', 'id', id)
            const localVarPath = `/did/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (versionTime !== undefined) {
                localVarQueryParameter['versionTime'] = versionTime;
            }

            if (versionId !== undefined) {
                localVarQueryParameter['versionId'] = versionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the did document metadata to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp 2021-09-26T18:18:36.855Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerDidControllerMetaData: async (id: string, versionTime?: string, versionId?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('observerDidControllerMetaData', 'id', id)
            const localVarPath = `/did/{id}/metadata`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (versionTime !== undefined) {
                localVarQueryParameter['versionTime'] = versionTime;
            }

            if (versionId !== undefined) {
                localVarQueryParameter['versionId'] = versionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DidObserverApi - functional programming interface
 * @export
 */
export const DidObserverApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DidObserverApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns the genesis block to build the chain of trust
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async observerDidControllerGenesis(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.observerDidControllerGenesis(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary returns the did document to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] return the did document that was present to 2021-09-26T18:18:36.854Z
         * @param {number} [versionId] return the did document with this version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async observerDidControllerGetDoc(id: string, versionTime?: string, versionId?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.observerDidControllerGetDoc(id, versionTime, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary returns the transaction to assemble a did document.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp like 2021-09-26T18:18:36.853Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async observerDidControllerGetTransactions(id: string, versionTime?: string, versionId?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DidTransaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.observerDidControllerGetTransactions(id, versionTime, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary returns the did document metadata to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp 2021-09-26T18:18:36.855Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async observerDidControllerMetaData(id: string, versionTime?: string, versionId?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.observerDidControllerMetaData(id, versionTime, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DidObserverApi - factory interface
 * @export
 */
export const DidObserverApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DidObserverApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns the genesis block to build the chain of trust
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerDidControllerGenesis(options?: any): AxiosPromise<void> {
            return localVarFp.observerDidControllerGenesis(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the did document to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] return the did document that was present to 2021-09-26T18:18:36.854Z
         * @param {number} [versionId] return the did document with this version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerDidControllerGetDoc(id: string, versionTime?: string, versionId?: number, options?: any): AxiosPromise<DocResponse> {
            return localVarFp.observerDidControllerGetDoc(id, versionTime, versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the transaction to assemble a did document.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp like 2021-09-26T18:18:36.853Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerDidControllerGetTransactions(id: string, versionTime?: string, versionId?: number, options?: any): AxiosPromise<Array<DidTransaction>> {
            return localVarFp.observerDidControllerGetTransactions(id, versionTime, versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the did document metadata to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp 2021-09-26T18:18:36.855Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerDidControllerMetaData(id: string, versionTime?: string, versionId?: number, options?: any): AxiosPromise<void> {
            return localVarFp.observerDidControllerMetaData(id, versionTime, versionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DidObserverApi - object-oriented interface
 * @export
 * @class DidObserverApi
 * @extends {BaseAPI}
 */
export class DidObserverApi extends BaseAPI {
    /**
     * 
     * @summary Returns the genesis block to build the chain of trust
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DidObserverApi
     */
    public observerDidControllerGenesis(options?: any) {
        return DidObserverApiFp(this.configuration).observerDidControllerGenesis(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the did document to a did.
     * @param {string} id identifier of the did.
     * @param {string} [versionTime] return the did document that was present to 2021-09-26T18:18:36.854Z
     * @param {number} [versionId] return the did document with this version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DidObserverApi
     */
    public observerDidControllerGetDoc(id: string, versionTime?: string, versionId?: number, options?: any) {
        return DidObserverApiFp(this.configuration).observerDidControllerGetDoc(id, versionTime, versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the transaction to assemble a did document.
     * @param {string} id identifier of the did.
     * @param {string} [versionTime] only request transactions that are less than the given timestamp like 2021-09-26T18:18:36.853Z
     * @param {number} [versionId] only request transactions that belong to reach the version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DidObserverApi
     */
    public observerDidControllerGetTransactions(id: string, versionTime?: string, versionId?: number, options?: any) {
        return DidObserverApiFp(this.configuration).observerDidControllerGetTransactions(id, versionTime, versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the did document metadata to a did.
     * @param {string} id identifier of the did.
     * @param {string} [versionTime] only request transactions that are less than the given timestamp 2021-09-26T18:18:36.855Z
     * @param {number} [versionId] only request transactions that belong to reach the version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DidObserverApi
     */
    public observerDidControllerMetaData(id: string, versionTime?: string, versionId?: number, options?: any) {
        return DidObserverApiFp(this.configuration).observerDidControllerMetaData(id, versionTime, versionId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HashObserverApi - axios parameter creator
 * @export
 */
export const HashObserverApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Looks for an entry to the hash.
         * @param {string} hash value of the hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerHashControllerGetHash: async (hash: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('observerHashControllerGetHash', 'hash', hash)
            const localVarPath = `/hash/{hash}`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HashObserverApi - functional programming interface
 * @export
 */
export const HashObserverApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HashObserverApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Looks for an entry to the hash.
         * @param {string} hash value of the hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async observerHashControllerGetHash(hash: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hash>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.observerHashControllerGetHash(hash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HashObserverApi - factory interface
 * @export
 */
export const HashObserverApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HashObserverApiFp(configuration)
    return {
        /**
         * 
         * @summary Looks for an entry to the hash.
         * @param {string} hash value of the hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerHashControllerGetHash(hash: string, options?: any): AxiosPromise<Hash> {
            return localVarFp.observerHashControllerGetHash(hash, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HashObserverApi - object-oriented interface
 * @export
 * @class HashObserverApi
 * @extends {BaseAPI}
 */
export class HashObserverApi extends BaseAPI {
    /**
     * 
     * @summary Looks for an entry to the hash.
     * @param {string} hash value of the hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HashObserverApi
     */
    public observerHashControllerGetHash(hash: string, options?: any) {
        return HashObserverApiFp(this.configuration).observerHashControllerGetHash(hash, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NodeObserverApi - axios parameter creator
 * @export
 */
export const NodeObserverApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns the type of the node and the service that was exposed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpObserverControllerInformation: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Pass an invite code to init this node.
         * @param {InviteNode} inviteNode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpObserverControllerInit: async (inviteNode: InviteNode, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inviteNode' is not null or undefined
            assertParamExists('httpObserverControllerInit', 'inviteNode', inviteNode)
            const localVarPath = `/init`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteNode, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Rebuilds the pki and hash database based on the local blockchain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpObserverControllerRebuild: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rebuild`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resets the node.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpObserverControllerReset: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NodeObserverApi - functional programming interface
 * @export
 */
export const NodeObserverApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NodeObserverApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns the type of the node and the service that was exposed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async httpObserverControllerInformation(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.httpObserverControllerInformation(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Pass an invite code to init this node.
         * @param {InviteNode} inviteNode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async httpObserverControllerInit(inviteNode: InviteNode, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.httpObserverControllerInit(inviteNode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Rebuilds the pki and hash database based on the local blockchain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async httpObserverControllerRebuild(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.httpObserverControllerRebuild(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Resets the node.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async httpObserverControllerReset(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.httpObserverControllerReset(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NodeObserverApi - factory interface
 * @export
 */
export const NodeObserverApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NodeObserverApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns the type of the node and the service that was exposed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpObserverControllerInformation(options?: any): AxiosPromise<void> {
            return localVarFp.httpObserverControllerInformation(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Pass an invite code to init this node.
         * @param {InviteNode} inviteNode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpObserverControllerInit(inviteNode: InviteNode, options?: any): AxiosPromise<void> {
            return localVarFp.httpObserverControllerInit(inviteNode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Rebuilds the pki and hash database based on the local blockchain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpObserverControllerRebuild(options?: any): AxiosPromise<void> {
            return localVarFp.httpObserverControllerRebuild(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Resets the node.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpObserverControllerReset(options?: any): AxiosPromise<void> {
            return localVarFp.httpObserverControllerReset(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NodeObserverApi - object-oriented interface
 * @export
 * @class NodeObserverApi
 * @extends {BaseAPI}
 */
export class NodeObserverApi extends BaseAPI {
    /**
     * 
     * @summary Returns the type of the node and the service that was exposed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeObserverApi
     */
    public httpObserverControllerInformation(options?: any) {
        return NodeObserverApiFp(this.configuration).httpObserverControllerInformation(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Pass an invite code to init this node.
     * @param {InviteNode} inviteNode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeObserverApi
     */
    public httpObserverControllerInit(inviteNode: InviteNode, options?: any) {
        return NodeObserverApiFp(this.configuration).httpObserverControllerInit(inviteNode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Rebuilds the pki and hash database based on the local blockchain.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeObserverApi
     */
    public httpObserverControllerRebuild(options?: any) {
        return NodeObserverApiFp(this.configuration).httpObserverControllerRebuild(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Resets the node.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeObserverApi
     */
    public httpObserverControllerReset(options?: any) {
        return NodeObserverApiFp(this.configuration).httpObserverControllerReset(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TemplateObserverApi - axios parameter creator
 * @export
 */
export const TemplateObserverApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Looks for an entry to the template.
         * @param {string} id id of the template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerTemplateControllerGetTemplate: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('observerTemplateControllerGetTemplate', 'id', id)
            const localVarPath = `/template/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplateObserverApi - functional programming interface
 * @export
 */
export const TemplateObserverApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TemplateObserverApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Looks for an entry to the template.
         * @param {string} id id of the template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async observerTemplateControllerGetTemplate(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Template>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.observerTemplateControllerGetTemplate(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TemplateObserverApi - factory interface
 * @export
 */
export const TemplateObserverApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TemplateObserverApiFp(configuration)
    return {
        /**
         * 
         * @summary Looks for an entry to the template.
         * @param {string} id id of the template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerTemplateControllerGetTemplate(id: string, options?: any): AxiosPromise<Template> {
            return localVarFp.observerTemplateControllerGetTemplate(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TemplateObserverApi - object-oriented interface
 * @export
 * @class TemplateObserverApi
 * @extends {BaseAPI}
 */
export class TemplateObserverApi extends BaseAPI {
    /**
     * 
     * @summary Looks for an entry to the template.
     * @param {string} id id of the template
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateObserverApi
     */
    public observerTemplateControllerGetTemplate(id: string, options?: any) {
        return TemplateObserverApiFp(this.configuration).observerTemplateControllerGetTemplate(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/* tslint:disable */
/* eslint-disable */
/**
 * Gateway interaction
 * Explore the functionality of an gateway
 *
 * The version of the OpenAPI document: 1.0.0 - f20cfc7657a97641
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Compression
 */
export interface Compression {
    /**
     * type of the compression
     * @type {string}
     * @memberof Compression
     */
    type: CompressionTypeEnum;
    /**
     * Json encoded information that are required for this kind of compression.
     * @type {string}
     * @memberof Compression
     */
    value?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum CompressionTypeEnum {
    Json = 'JSON',
    Proto = 'PROTO'
}

/**
 * 
 * @export
 * @interface ControllerManage
 */
export interface ControllerManage {
    /**
     * id that should be added to the controller list.
     * @type {Array<string>}
     * @memberof ControllerManage
     */
    add?: Array<string>;
    /**
     * id that should be removed from the controller list.
     * @type {Array<string>}
     * @memberof ControllerManage
     */
    remove?: Array<string>;
}
/**
 * 
 * @export
 * @interface CreateDidDto
 */
export interface CreateDidDto {
    /**
     * Identifier that belongs to the public key
     * @type {string}
     * @memberof CreateDidDto
     */
    identifier: string;
    /**
     * Invite code that allows the creation of a certificate that includes the public key of the identifier.
     * @type {string}
     * @memberof CreateDidDto
     */
    secret: string;
    /**
     * Value of the public key as a json web key.
     * @type {PublicKeyJwkDto}
     * @memberof CreateDidDto
     */
    publicKey: PublicKeyJwkDto;
}
/**
 * 
 * @export
 * @interface DidCreationResponse
 */
export interface DidCreationResponse {
    /**
     * additional metadata to the transaction
     * @type {PersistedTransaction}
     * @memberof DidCreationResponse
     */
    metaData: PersistedTransaction;
    /**
     * 
     * @type {DidTransactionDto}
     * @memberof DidCreationResponse
     */
    transaction: DidTransactionDto;
}
/**
 * 
 * @export
 * @interface DidPublicKey
 */
export interface DidPublicKey {
    /**
     * unique identifier of a key
     * @type {string}
     * @memberof DidPublicKey
     */
    id: string;
    /**
     * controller of the key
     * @type {string}
     * @memberof DidPublicKey
     */
    controller: string;
    /**
     * Type of the key
     * @type {string}
     * @memberof DidPublicKey
     */
    type: DidPublicKeyTypeEnum;
    /**
     * encoded key value
     * @type {PublicKeyJwkDto}
     * @memberof DidPublicKey
     */
    publicKeyJwk: PublicKeyJwkDto;
}

/**
    * @export
    * @enum {string}
    */
export enum DidPublicKeyTypeEnum {
    RsaVerificationKey2018 = 'RsaVerificationKey2018'
}

/**
 * 
 * @export
 * @interface DidService
 */
export interface DidService {
    /**
     * unique identifier of a service
     * @type {string}
     * @memberof DidService
     */
    id: string;
    /**
     * name of the service
     * @type {string}
     * @memberof DidService
     */
    type: string;
    /**
     * url to the service
     * @type {string}
     * @memberof DidService
     */
    endpoint: string;
}
/**
 * 
 * @export
 * @interface DidStructure
 */
export interface DidStructure {
    /**
     * unique identifier of a did
     * @type {string}
     * @memberof DidStructure
     */
    id: string;
    /**
     * 
     * @type {ControllerManage}
     * @memberof DidStructure
     */
    controller?: ControllerManage;
    /**
     * 
     * @type {RoleManage}
     * @memberof DidStructure
     */
    role?: RoleManage;
    /**
     * 
     * @type {VerificationMethod}
     * @memberof DidStructure
     */
    verificationMethod?: VerificationMethod;
    /**
     * 
     * @type {ServiceMange}
     * @memberof DidStructure
     */
    service?: ServiceMange;
    /**
     * 
     * @type {VerificationRelationshipManage}
     * @memberof DidStructure
     */
    authentication?: VerificationRelationshipManage;
    /**
     * 
     * @type {VerificationRelationshipManage}
     * @memberof DidStructure
     */
    assertionMethod?: VerificationRelationshipManage;
    /**
     * 
     * @type {VerificationRelationshipManage}
     * @memberof DidStructure
     */
    keyAgreement?: VerificationRelationshipManage;
    /**
     * 
     * @type {VerificationRelationshipManage}
     * @memberof DidStructure
     */
    modification?: VerificationRelationshipManage;
    /**
     * 
     * @type {VerificationRelationshipManage}
     * @memberof DidStructure
     */
    capabilityDelegation?: VerificationRelationshipManage;
    /**
     * 
     * @type {VerificationRelationshipManage}
     * @memberof DidStructure
     */
    capabilityInvocation?: VerificationRelationshipManage;
}
/**
 * 
 * @export
 * @interface DidTransactionBody
 */
export interface DidTransactionBody {
    /**
     * Version number of the transaction.
     * @type {number}
     * @memberof DidTransactionBody
     */
    version: number;
    /**
     * timestamp when transaction was created.
     * @type {string}
     * @memberof DidTransactionBody
     */
    date: string;
    /**
     * 
     * @type {TransactionType}
     * @memberof DidTransactionBody
     */
    type: TransactionType;
    /**
     * signature of the did document after applying the changes
     * @type {SignatureInfo}
     * @memberof DidTransactionBody
     */
    didDocSignature: SignatureInfo;
    /**
     * 
     * @type {DidStructure}
     * @memberof DidTransactionBody
     */
    value: DidStructure;
}
/**
 * 
 * @export
 * @interface DidTransactionDto
 */
export interface DidTransactionDto {
    /**
     * Version number of the base transaction.
     * @type {number}
     * @memberof DidTransactionDto
     */
    version: number;
    /**
     * 
     * @type {DidTransactionBody}
     * @memberof DidTransactionDto
     */
    body: DidTransactionBody;
    /**
     * 
     * @type {TransactionMetadata}
     * @memberof DidTransactionDto
     */
    metadata: TransactionMetadata;
    /**
     * 
     * @type {SignatureInfo}
     * @memberof DidTransactionDto
     */
    signature: SignatureInfo;
}
/**
 * 
 * @export
 * @interface HashCreationResponse
 */
export interface HashCreationResponse {
    /**
     * additional metadata to the transaction
     * @type {PersistedTransaction}
     * @memberof HashCreationResponse
     */
    metaData: PersistedTransaction;
    /**
     * transaction that was persisted.
     * @type {TransactionHashCreationDto}
     * @memberof HashCreationResponse
     */
    transaction: TransactionHashCreationDto;
}
/**
 * 
 * @export
 * @interface HashCreationTransactionBody
 */
export interface HashCreationTransactionBody {
    /**
     * Version number of the transaction.
     * @type {number}
     * @memberof HashCreationTransactionBody
     */
    version: number;
    /**
     * timestamp when transaction was created.
     * @type {string}
     * @memberof HashCreationTransactionBody
     */
    date: string;
    /**
     * 
     * @type {TransactionType}
     * @memberof HashCreationTransactionBody
     */
    type: TransactionType;
    /**
     * 
     * @type {TransactionHashValue}
     * @memberof HashCreationTransactionBody
     */
    value: TransactionHashValue;
}
/**
 * 
 * @export
 * @interface HashRevocationResponse
 */
export interface HashRevocationResponse {
    /**
     * additional metadata to the transaction
     * @type {PersistedTransaction}
     * @memberof HashRevocationResponse
     */
    metaData: PersistedTransaction;
    /**
     * transaction that was persisted.
     * @type {TransactionHashRevocationDto}
     * @memberof HashRevocationResponse
     */
    transaction: TransactionHashRevocationDto;
}
/**
 * 
 * @export
 * @interface HashRevocationTransactionBody
 */
export interface HashRevocationTransactionBody {
    /**
     * Version number of the transaction.
     * @type {number}
     * @memberof HashRevocationTransactionBody
     */
    version: number;
    /**
     * timestamp when transaction was created.
     * @type {string}
     * @memberof HashRevocationTransactionBody
     */
    date: string;
    /**
     * 
     * @type {TransactionType}
     * @memberof HashRevocationTransactionBody
     */
    type: TransactionType;
    /**
     * 
     * @type {TransactionHashValue}
     * @memberof HashRevocationTransactionBody
     */
    value: TransactionHashValue;
}
/**
 * 
 * @export
 * @interface ImportedMetadata
 */
export interface ImportedMetadata {
    /**
     * timestamp when transaction was persisted in the old blockchain.
     * @type {string}
     * @memberof ImportedMetadata
     */
    date: string;
    /**
     * 
     * @type {SignatureInfo}
     * @memberof ImportedMetadata
     */
    imported: SignatureInfo;
}
/**
 * 
 * @export
 * @interface InviteNode
 */
export interface InviteNode {
    /**
     * id of the did
     * @type {string}
     * @memberof InviteNode
     */
    id: string;
    /**
     * Secret token
     * @type {string}
     * @memberof InviteNode
     */
    secret: string;
    /**
     * Url of the node endpoint
     * @type {string}
     * @memberof InviteNode
     */
    url: string;
}
/**
 * 
 * @export
 * @interface InviteRequest
 */
export interface InviteRequest {
    /**
     * Unique identifier that is used for the new did.
     * @type {string}
     * @memberof InviteRequest
     */
    id?: string;
    /**
     * Secret that is used for authentication
     * @type {string}
     * @memberof InviteRequest
     */
    secret?: string;
    /**
     * Unique identifier that will be stored to identify the did with a human readable name.
     * @type {string}
     * @memberof InviteRequest
     */
    name: string;
    /**
     * Describes for what type of role in the network the secret is allowed to be used
     * @type {string}
     * @memberof InviteRequest
     */
    role: InviteRequestRoleEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum InviteRequestRoleEnum {
    Validator = 'validator',
    Gateway = 'gateway',
    Observer = 'observer',
    Client = 'client'
}

/**
 * 
 * @export
 * @interface PersistedBlock
 */
export interface PersistedBlock {
    /**
     * 
     * @type {number}
     * @memberof PersistedBlock
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof PersistedBlock
     */
    createdAt: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PersistedBlock
     */
    validators: Array<string>;
}
/**
 * 
 * @export
 * @interface PersistedTransaction
 */
export interface PersistedTransaction {
    /**
     * 
     * @type {PersistedTransactionMetaData}
     * @memberof PersistedTransaction
     */
    transaction: PersistedTransactionMetaData;
    /**
     * 
     * @type {PersistedBlock}
     * @memberof PersistedTransaction
     */
    block: PersistedBlock;
}
/**
 * 
 * @export
 * @interface PersistedTransactionMetaData
 */
export interface PersistedTransactionMetaData {
    /**
     * 
     * @type {string}
     * @memberof PersistedTransactionMetaData
     */
    hash: string;
    /**
     * 
     * @type {string}
     * @memberof PersistedTransactionMetaData
     */
    persisted: string;
}
/**
 * 
 * @export
 * @interface PublicKeyJwkDto
 */
export interface PublicKeyJwkDto {
    /**
     * How the key was meant to be used
     * @type {Array<string>}
     * @memberof PublicKeyJwkDto
     */
    key_ops?: Array<string>;
    /**
     * The family of cryptographic algorithms used with the key.
     * @type {string}
     * @memberof PublicKeyJwkDto
     */
    kty?: string;
    /**
     * The modulus for the RSA public key.
     * @type {string}
     * @memberof PublicKeyJwkDto
     */
    n?: string;
    /**
     * The exponent for the RSA public key.
     * @type {string}
     * @memberof PublicKeyJwkDto
     */
    e?: string;
    /**
     * The specific cryptographic algorithm used with the key.
     * @type {string}
     * @memberof PublicKeyJwkDto
     */
    alg?: string;
}
/**
 * 
 * @export
 * @interface RoleManage
 */
export interface RoleManage {
    /**
     * roles that should be added to the did
     * @type {Array<string>}
     * @memberof RoleManage
     */
    add?: Array<RoleManageAddEnum>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RoleManage
     */
    remove?: Array<string>;
}

/**
    * @export
    * @enum {string}
    */
export enum RoleManageAddEnum {
    Validator = 'validator',
    Gateway = 'gateway',
    Observer = 'observer',
    Client = 'client'
}

/**
 * 
 * @export
 * @interface ServiceMange
 */
export interface ServiceMange {
    /**
     * List of services that should be added to the did document.
     * @type {Array<DidService>}
     * @memberof ServiceMange
     */
    add?: Array<DidService>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ServiceMange
     */
    remove?: Array<string>;
}
/**
 * 
 * @export
 * @interface SignatureDto
 */
export interface SignatureDto {
    /**
     * Identifier of the issuer and the used key
     * @type {string}
     * @memberof SignatureDto
     */
    identifier: string;
    /**
     * The actual signature as a hex encoded string.
     * @type {string}
     * @memberof SignatureDto
     */
    signature: string;
}
/**
 * 
 * @export
 * @interface SignatureInfo
 */
export interface SignatureInfo {
    /**
     * Type of the signature procedure.
     * @type {string}
     * @memberof SignatureInfo
     */
    type: SignatureInfoTypeEnum;
    /**
     * signature of the document values.
     * @type {Array<SignatureDto>}
     * @memberof SignatureInfo
     */
    values: Array<SignatureDto>;
}

/**
    * @export
    * @enum {string}
    */
export enum SignatureInfoTypeEnum {
    Single = 'single',
    Multi = 'multi'
}

/**
 * 
 * @export
 * @interface TemplateCreationResponse
 */
export interface TemplateCreationResponse {
    /**
     * additional metadata to the transaction
     * @type {PersistedTransaction}
     * @memberof TemplateCreationResponse
     */
    metaData: PersistedTransaction;
    /**
     * transaction that was persisted.
     * @type {TemplateTransactionDto}
     * @memberof TemplateCreationResponse
     */
    transaction: TemplateTransactionDto;
}
/**
 * 
 * @export
 * @interface TemplateStructure
 */
export interface TemplateStructure {
    /**
     * unique identifier of a template
     * @type {string}
     * @memberof TemplateStructure
     */
    id: string;
    /**
     * template that should be used.
     * @type {string}
     * @memberof TemplateStructure
     */
    template: string;
    /**
     * json schema to validate the data that should be parsed into the
     * @type {string}
     * @memberof TemplateStructure
     */
    schema: string;
    /**
     * 
     * @type {Compression}
     * @memberof TemplateStructure
     */
    compression: Compression;
}
/**
 * 
 * @export
 * @interface TemplateTransactionBody
 */
export interface TemplateTransactionBody {
    /**
     * Version number of the transaction.
     * @type {number}
     * @memberof TemplateTransactionBody
     */
    version: number;
    /**
     * timestamp when transaction was created.
     * @type {string}
     * @memberof TemplateTransactionBody
     */
    date: string;
    /**
     * 
     * @type {TransactionType}
     * @memberof TemplateTransactionBody
     */
    type: TransactionType;
    /**
     * 
     * @type {TemplateStructure}
     * @memberof TemplateTransactionBody
     */
    value: TemplateStructure;
}
/**
 * 
 * @export
 * @interface TemplateTransactionDto
 */
export interface TemplateTransactionDto {
    /**
     * Version number of the base transaction.
     * @type {number}
     * @memberof TemplateTransactionDto
     */
    version: number;
    /**
     * 
     * @type {TemplateTransactionBody}
     * @memberof TemplateTransactionDto
     */
    body: TemplateTransactionBody;
    /**
     * 
     * @type {TransactionMetadata}
     * @memberof TemplateTransactionDto
     */
    metadata: TransactionMetadata;
    /**
     * 
     * @type {SignatureInfo}
     * @memberof TemplateTransactionDto
     */
    signature: SignatureInfo;
}
/**
 * 
 * @export
 * @interface TransactionHashCreationDto
 */
export interface TransactionHashCreationDto {
    /**
     * Version number of the base transaction.
     * @type {number}
     * @memberof TransactionHashCreationDto
     */
    version: number;
    /**
     * 
     * @type {HashCreationTransactionBody}
     * @memberof TransactionHashCreationDto
     */
    body: HashCreationTransactionBody;
    /**
     * 
     * @type {TransactionMetadata}
     * @memberof TransactionHashCreationDto
     */
    metadata: TransactionMetadata;
    /**
     * 
     * @type {SignatureInfo}
     * @memberof TransactionHashCreationDto
     */
    signature: SignatureInfo;
}
/**
 * 
 * @export
 * @interface TransactionHashRevocationDto
 */
export interface TransactionHashRevocationDto {
    /**
     * Version number of the base transaction.
     * @type {number}
     * @memberof TransactionHashRevocationDto
     */
    version: number;
    /**
     * 
     * @type {HashRevocationTransactionBody}
     * @memberof TransactionHashRevocationDto
     */
    body: HashRevocationTransactionBody;
    /**
     * 
     * @type {TransactionMetadata}
     * @memberof TransactionHashRevocationDto
     */
    metadata: TransactionMetadata;
    /**
     * 
     * @type {SignatureInfo}
     * @memberof TransactionHashRevocationDto
     */
    signature: SignatureInfo;
}
/**
 * 
 * @export
 * @interface TransactionHashValue
 */
export interface TransactionHashValue {
    /**
     * hashBlock of the hash
     * @type {string}
     * @memberof TransactionHashValue
     */
    hash: string;
    /**
     * Used algorithm for the hash.
     * @type {string}
     * @memberof TransactionHashValue
     */
    algorithm: string;
}
/**
 * 
 * @export
 * @interface TransactionMetadata
 */
export interface TransactionMetadata {
    /**
     * Version number of the metadata.
     * @type {number}
     * @memberof TransactionMetadata
     */
    version: number;
    /**
     * 
     * @type {ImportedMetadata}
     * @memberof TransactionMetadata
     */
    imported?: ImportedMetadata;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum TransactionType {
    HashCreation = 'HashCreation',
    HashRevocation = 'HashRevocation',
    SecurityLimit = 'SecurityLimit',
    SecurityRecaptcha = 'SecurityRecaptcha',
    Did = 'Did',
    SchemaCreation = 'SchemaCreation',
    ClaimDefinition = 'ClaimDefinition',
    RevocationRegistryCreation = 'RevocationRegistryCreation',
    RevocationEntry = 'RevocationEntry',
    Template = 'Template'
}

/**
 * 
 * @export
 * @interface VerificationMethod
 */
export interface VerificationMethod {
    /**
     * List of public keys that should be added to the did document.
     * @type {Array<DidPublicKey>}
     * @memberof VerificationMethod
     */
    add?: Array<DidPublicKey>;
    /**
     * 
     * @type {Array<string>}
     * @memberof VerificationMethod
     */
    remove?: Array<string>;
}
/**
 * 
 * @export
 * @interface VerificationRelationshipManage
 */
export interface VerificationRelationshipManage {
    /**
     * id that should be removed from the list
     * @type {Array<string>}
     * @memberof VerificationRelationshipManage
     */
    add?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof VerificationRelationshipManage
     */
    remove?: Array<string>;
}

/**
 * DefaultGatewayApi - axios parameter creator
 * @export
 */
export const DefaultGatewayApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promControllerIndex: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultGatewayApi - functional programming interface
 * @export
 */
export const DefaultGatewayApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultGatewayApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promControllerIndex(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promControllerIndex(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultGatewayApi - factory interface
 * @export
 */
export const DefaultGatewayApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultGatewayApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promControllerIndex(options?: any): AxiosPromise<void> {
            return localVarFp.promControllerIndex(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultGatewayApi - object-oriented interface
 * @export
 * @class DefaultGatewayApi
 * @extends {BaseAPI}
 */
export class DefaultGatewayApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultGatewayApi
     */
    public promControllerIndex(options?: any) {
        return DefaultGatewayApiFp(this.configuration).promControllerIndex(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DidGatewayApi - axios parameter creator
 * @export
 */
export const DidGatewayApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Signs the public key of the Client.
         * @param {CreateDidDto} createDidDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewayDidControllerCreate: async (createDidDto: CreateDidDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createDidDto' is not null or undefined
            assertParamExists('gatewayDidControllerCreate', 'createDidDto', createDidDto)
            const localVarPath = `/did/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDidDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generates an invite for a new Client
         * @param {InviteRequest} inviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewayDidControllerInvite: async (inviteRequest: InviteRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inviteRequest' is not null or undefined
            assertParamExists('gatewayDidControllerInvite', 'inviteRequest', inviteRequest)
            const localVarPath = `/did/invite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resolves the name to a given did that was created by this node.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewayDidControllerResolve: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gatewayDidControllerResolve', 'id', id)
            const localVarPath = `/did/resolve/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds new did document to the chain.
         * @param {DidTransactionDto} didTransactionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewayDidControllerStore: async (didTransactionDto: DidTransactionDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'didTransactionDto' is not null or undefined
            assertParamExists('gatewayDidControllerStore', 'didTransactionDto', didTransactionDto)
            const localVarPath = `/did`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(didTransactionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DidGatewayApi - functional programming interface
 * @export
 */
export const DidGatewayApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DidGatewayApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Signs the public key of the Client.
         * @param {CreateDidDto} createDidDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gatewayDidControllerCreate(createDidDto: CreateDidDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DidCreationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gatewayDidControllerCreate(createDidDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Generates an invite for a new Client
         * @param {InviteRequest} inviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gatewayDidControllerInvite(inviteRequest: InviteRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gatewayDidControllerInvite(inviteRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Resolves the name to a given did that was created by this node.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gatewayDidControllerResolve(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gatewayDidControllerResolve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Adds new did document to the chain.
         * @param {DidTransactionDto} didTransactionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gatewayDidControllerStore(didTransactionDto: DidTransactionDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gatewayDidControllerStore(didTransactionDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DidGatewayApi - factory interface
 * @export
 */
export const DidGatewayApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DidGatewayApiFp(configuration)
    return {
        /**
         * 
         * @summary Signs the public key of the Client.
         * @param {CreateDidDto} createDidDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewayDidControllerCreate(createDidDto: CreateDidDto, options?: any): AxiosPromise<DidCreationResponse> {
            return localVarFp.gatewayDidControllerCreate(createDidDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generates an invite for a new Client
         * @param {InviteRequest} inviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewayDidControllerInvite(inviteRequest: InviteRequest, options?: any): AxiosPromise<InviteRequest> {
            return localVarFp.gatewayDidControllerInvite(inviteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Resolves the name to a given did that was created by this node.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewayDidControllerResolve(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.gatewayDidControllerResolve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds new did document to the chain.
         * @param {DidTransactionDto} didTransactionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewayDidControllerStore(didTransactionDto: DidTransactionDto, options?: any): AxiosPromise<void> {
            return localVarFp.gatewayDidControllerStore(didTransactionDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DidGatewayApi - object-oriented interface
 * @export
 * @class DidGatewayApi
 * @extends {BaseAPI}
 */
export class DidGatewayApi extends BaseAPI {
    /**
     * 
     * @summary Signs the public key of the Client.
     * @param {CreateDidDto} createDidDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DidGatewayApi
     */
    public gatewayDidControllerCreate(createDidDto: CreateDidDto, options?: any) {
        return DidGatewayApiFp(this.configuration).gatewayDidControllerCreate(createDidDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generates an invite for a new Client
     * @param {InviteRequest} inviteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DidGatewayApi
     */
    public gatewayDidControllerInvite(inviteRequest: InviteRequest, options?: any) {
        return DidGatewayApiFp(this.configuration).gatewayDidControllerInvite(inviteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Resolves the name to a given did that was created by this node.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DidGatewayApi
     */
    public gatewayDidControllerResolve(id: string, options?: any) {
        return DidGatewayApiFp(this.configuration).gatewayDidControllerResolve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds new did document to the chain.
     * @param {DidTransactionDto} didTransactionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DidGatewayApi
     */
    public gatewayDidControllerStore(didTransactionDto: DidTransactionDto, options?: any) {
        return DidGatewayApiFp(this.configuration).gatewayDidControllerStore(didTransactionDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HashGatewayApi - axios parameter creator
 * @export
 */
export const HashGatewayApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds new hash to the chain.
         * @param {TransactionHashCreationDto} transactionHashCreationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewayHashControllerCreate: async (transactionHashCreationDto: TransactionHashCreationDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionHashCreationDto' is not null or undefined
            assertParamExists('gatewayHashControllerCreate', 'transactionHashCreationDto', transactionHashCreationDto)
            const localVarPath = `/hash/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionHashCreationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Revokes a hash.
         * @param {TransactionHashRevocationDto} transactionHashRevocationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewayHashControllerRevoke: async (transactionHashRevocationDto: TransactionHashRevocationDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionHashRevocationDto' is not null or undefined
            assertParamExists('gatewayHashControllerRevoke', 'transactionHashRevocationDto', transactionHashRevocationDto)
            const localVarPath = `/hash/revoke`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionHashRevocationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HashGatewayApi - functional programming interface
 * @export
 */
export const HashGatewayApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HashGatewayApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Adds new hash to the chain.
         * @param {TransactionHashCreationDto} transactionHashCreationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gatewayHashControllerCreate(transactionHashCreationDto: TransactionHashCreationDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HashCreationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gatewayHashControllerCreate(transactionHashCreationDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Revokes a hash.
         * @param {TransactionHashRevocationDto} transactionHashRevocationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gatewayHashControllerRevoke(transactionHashRevocationDto: TransactionHashRevocationDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HashRevocationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gatewayHashControllerRevoke(transactionHashRevocationDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HashGatewayApi - factory interface
 * @export
 */
export const HashGatewayApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HashGatewayApiFp(configuration)
    return {
        /**
         * 
         * @summary Adds new hash to the chain.
         * @param {TransactionHashCreationDto} transactionHashCreationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewayHashControllerCreate(transactionHashCreationDto: TransactionHashCreationDto, options?: any): AxiosPromise<HashCreationResponse> {
            return localVarFp.gatewayHashControllerCreate(transactionHashCreationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Revokes a hash.
         * @param {TransactionHashRevocationDto} transactionHashRevocationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewayHashControllerRevoke(transactionHashRevocationDto: TransactionHashRevocationDto, options?: any): AxiosPromise<HashRevocationResponse> {
            return localVarFp.gatewayHashControllerRevoke(transactionHashRevocationDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HashGatewayApi - object-oriented interface
 * @export
 * @class HashGatewayApi
 * @extends {BaseAPI}
 */
export class HashGatewayApi extends BaseAPI {
    /**
     * 
     * @summary Adds new hash to the chain.
     * @param {TransactionHashCreationDto} transactionHashCreationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HashGatewayApi
     */
    public gatewayHashControllerCreate(transactionHashCreationDto: TransactionHashCreationDto, options?: any) {
        return HashGatewayApiFp(this.configuration).gatewayHashControllerCreate(transactionHashCreationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Revokes a hash.
     * @param {TransactionHashRevocationDto} transactionHashRevocationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HashGatewayApi
     */
    public gatewayHashControllerRevoke(transactionHashRevocationDto: TransactionHashRevocationDto, options?: any) {
        return HashGatewayApiFp(this.configuration).gatewayHashControllerRevoke(transactionHashRevocationDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NodeGatewayApi - axios parameter creator
 * @export
 */
export const NodeGatewayApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns the type of the node and the service that was exposed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpGatewayControllerInformation: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Pass an invite code to init this node.
         * @param {InviteNode} inviteNode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpGatewayControllerInit: async (inviteNode: InviteNode, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inviteNode' is not null or undefined
            assertParamExists('httpGatewayControllerInit', 'inviteNode', inviteNode)
            const localVarPath = `/init`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteNode, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Rebuilds the pki and hash database based on the local blockchain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpGatewayControllerRebuild: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rebuild`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resets the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpGatewayControllerReset: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NodeGatewayApi - functional programming interface
 * @export
 */
export const NodeGatewayApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NodeGatewayApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns the type of the node and the service that was exposed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async httpGatewayControllerInformation(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.httpGatewayControllerInformation(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Pass an invite code to init this node.
         * @param {InviteNode} inviteNode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async httpGatewayControllerInit(inviteNode: InviteNode, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.httpGatewayControllerInit(inviteNode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Rebuilds the pki and hash database based on the local blockchain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async httpGatewayControllerRebuild(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.httpGatewayControllerRebuild(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Resets the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async httpGatewayControllerReset(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.httpGatewayControllerReset(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NodeGatewayApi - factory interface
 * @export
 */
export const NodeGatewayApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NodeGatewayApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns the type of the node and the service that was exposed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpGatewayControllerInformation(options?: any): AxiosPromise<void> {
            return localVarFp.httpGatewayControllerInformation(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Pass an invite code to init this node.
         * @param {InviteNode} inviteNode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpGatewayControllerInit(inviteNode: InviteNode, options?: any): AxiosPromise<void> {
            return localVarFp.httpGatewayControllerInit(inviteNode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Rebuilds the pki and hash database based on the local blockchain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpGatewayControllerRebuild(options?: any): AxiosPromise<void> {
            return localVarFp.httpGatewayControllerRebuild(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Resets the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpGatewayControllerReset(options?: any): AxiosPromise<void> {
            return localVarFp.httpGatewayControllerReset(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NodeGatewayApi - object-oriented interface
 * @export
 * @class NodeGatewayApi
 * @extends {BaseAPI}
 */
export class NodeGatewayApi extends BaseAPI {
    /**
     * 
     * @summary Returns the type of the node and the service that was exposed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeGatewayApi
     */
    public httpGatewayControllerInformation(options?: any) {
        return NodeGatewayApiFp(this.configuration).httpGatewayControllerInformation(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Pass an invite code to init this node.
     * @param {InviteNode} inviteNode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeGatewayApi
     */
    public httpGatewayControllerInit(inviteNode: InviteNode, options?: any) {
        return NodeGatewayApiFp(this.configuration).httpGatewayControllerInit(inviteNode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Rebuilds the pki and hash database based on the local blockchain.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeGatewayApi
     */
    public httpGatewayControllerRebuild(options?: any) {
        return NodeGatewayApiFp(this.configuration).httpGatewayControllerRebuild(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Resets the node
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeGatewayApi
     */
    public httpGatewayControllerReset(options?: any) {
        return NodeGatewayApiFp(this.configuration).httpGatewayControllerReset(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TemplateGatewayApi - axios parameter creator
 * @export
 */
export const TemplateGatewayApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds new template to the chain.
         * @param {TemplateTransactionDto} templateTransactionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewayTemplateControllerCreate: async (templateTransactionDto: TemplateTransactionDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateTransactionDto' is not null or undefined
            assertParamExists('gatewayTemplateControllerCreate', 'templateTransactionDto', templateTransactionDto)
            const localVarPath = `/template`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(templateTransactionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplateGatewayApi - functional programming interface
 * @export
 */
export const TemplateGatewayApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TemplateGatewayApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Adds new template to the chain.
         * @param {TemplateTransactionDto} templateTransactionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gatewayTemplateControllerCreate(templateTransactionDto: TemplateTransactionDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplateCreationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gatewayTemplateControllerCreate(templateTransactionDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TemplateGatewayApi - factory interface
 * @export
 */
export const TemplateGatewayApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TemplateGatewayApiFp(configuration)
    return {
        /**
         * 
         * @summary Adds new template to the chain.
         * @param {TemplateTransactionDto} templateTransactionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewayTemplateControllerCreate(templateTransactionDto: TemplateTransactionDto, options?: any): AxiosPromise<TemplateCreationResponse> {
            return localVarFp.gatewayTemplateControllerCreate(templateTransactionDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TemplateGatewayApi - object-oriented interface
 * @export
 * @class TemplateGatewayApi
 * @extends {BaseAPI}
 */
export class TemplateGatewayApi extends BaseAPI {
    /**
     * 
     * @summary Adds new template to the chain.
     * @param {TemplateTransactionDto} templateTransactionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateGatewayApi
     */
    public gatewayTemplateControllerCreate(templateTransactionDto: TemplateTransactionDto, options?: any) {
        return TemplateGatewayApiFp(this.configuration).gatewayTemplateControllerCreate(templateTransactionDto, options).then((request) => request(this.axios, this.basePath));
    }
}



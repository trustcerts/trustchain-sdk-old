/* tslint:disable */
/* eslint-disable */
/**
 * Platform interaction
 * Explore the functionality of the platform
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccountInformation
 */
export interface AccountInformation {
    /**
     * 
     * @type {string}
     * @memberof AccountInformation
     */
    'prename': string;
    /**
     * 
     * @type {string}
     * @memberof AccountInformation
     */
    'surname': string;
}
/**
 * 
 * @export
 * @interface Contract
 */
export interface Contract {
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    'subject': string;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    'message': string;
    /**
     * 
     * @type {Array<Participant>}
     * @memberof Contract
     */
    'participants': Array<Participant>;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    'repeat'?: ContractRepeatEnum;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    'nextRepeat'?: string;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    '_id': string;
    /**
     * 
     * @type {User}
     * @memberof Contract
     */
    'user': User;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    'file': string;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    'createdAt': string;
}

/**
    * @export
    * @enum {string}
    */
export enum ContractRepeatEnum {
    Daily = 'daily',
    Weekly = 'weekly',
    Monthly = 'monthly'
}

/**
 * 
 * @export
 * @interface ContractInput
 */
export interface ContractInput {
    /**
     * 
     * @type {string}
     * @memberof ContractInput
     */
    'fieldType': string;
    /**
     * 
     * @type {string}
     * @memberof ContractInput
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface ContractMetaData
 */
export interface ContractMetaData {
    /**
     * 
     * @type {Array<Field>}
     * @memberof ContractMetaData
     */
    'fields'?: Array<Field>;
    /**
     * 
     * @type {UserContract}
     * @memberof ContractMetaData
     */
    'user': UserContract;
}
/**
 * 
 * @export
 * @interface ContractTemplate
 */
export interface ContractTemplate {
    /**
     * 
     * @type {string}
     * @memberof ContractTemplate
     */
    '_id': string;
    /**
     * 
     * @type {User}
     * @memberof ContractTemplate
     */
    'user': User;
    /**
     * 
     * @type {string}
     * @memberof ContractTemplate
     */
    'file': string;
    /**
     * 
     * @type {string}
     * @memberof ContractTemplate
     */
    'name': string;
    /**
     * 
     * @type {Array<Stakeholder>}
     * @memberof ContractTemplate
     */
    'participants': Array<Stakeholder>;
    /**
     * 
     * @type {string}
     * @memberof ContractTemplate
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface CreateContractDto
 */
export interface CreateContractDto {
    /**
     * 
     * @type {string}
     * @memberof CreateContractDto
     */
    'subject': string;
    /**
     * 
     * @type {string}
     * @memberof CreateContractDto
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof CreateContractDto
     */
    'host': string;
    /**
     * 
     * @type {string}
     * @memberof CreateContractDto
     */
    'repeat'?: CreateContractDtoRepeatEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateContractDto
     */
    'file': string;
    /**
     * 
     * @type {string}
     * @memberof CreateContractDto
     */
    'name'?: string;
    /**
     * 
     * @type {Array<ContractMetaData>}
     * @memberof CreateContractDto
     */
    'metaData': Array<ContractMetaData>;
}

/**
    * @export
    * @enum {string}
    */
export enum CreateContractDtoRepeatEnum {
    Daily = 'daily',
    Weekly = 'weekly',
    Monthly = 'monthly'
}

/**
 * 
 * @export
 * @interface CreateContractResponse
 */
export interface CreateContractResponse {
    /**
     * 
     * @type {string}
     * @memberof CreateContractResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CreateContractResponse
     */
    'secret'?: string;
}
/**
 * 
 * @export
 * @interface CreateCredentialDto
 */
export interface CreateCredentialDto {
    /**
     * 
     * @type {string}
     * @memberof CreateCredentialDto
     */
    'did': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCredentialDto
     */
    'name': string;
    /**
     * 
     * @type {CredentialValidationSchema}
     * @memberof CreateCredentialDto
     */
    'schema': CredentialValidationSchema;
    /**
     * 
     * @type {string}
     * @memberof CreateCredentialDto
     */
    'user': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCredentialDto
     */
    'verifier': string;
}
/**
 * 
 * @export
 * @interface CreateInputDto
 */
export interface CreateInputDto {
    /**
     * 
     * @type {string}
     * @memberof CreateInputDto
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof CreateInputDto
     */
    'file': string;
}
/**
 * 
 * @export
 * @interface CreateTemplate
 */
export interface CreateTemplate {
    /**
     * 
     * @type {string}
     * @memberof CreateTemplate
     */
    'file': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTemplate
     */
    'name'?: string;
    /**
     * 
     * @type {Array<ContractMetaData>}
     * @memberof CreateTemplate
     */
    'metaData': Array<ContractMetaData>;
}
/**
 * 
 * @export
 * @interface Credential
 */
export interface Credential {
    /**
     * 
     * @type {string}
     * @memberof Credential
     */
    '_id': string;
    /**
     * 
     * @type {Template}
     * @memberof Credential
     */
    'template': Template;
    /**
     * 
     * @type {User}
     * @memberof Credential
     */
    'user': User;
    /**
     * 
     * @type {object}
     * @memberof Credential
     */
    'values': object;
}
/**
 * 
 * @export
 * @interface CredentialValidationSchema
 */
export interface CredentialValidationSchema {
    /**
     * 
     * @type {string}
     * @memberof CredentialValidationSchema
     */
    'type': string;
    /**
     * 
     * @type {object}
     * @memberof CredentialValidationSchema
     */
    'properties': object;
    /**
     * 
     * @type {Array<string>}
     * @memberof CredentialValidationSchema
     */
    'required': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof CredentialValidationSchema
     */
    'additionalProperties': boolean;
}
/**
 * 
 * @export
 * @interface DashboardResponse
 */
export interface DashboardResponse {
    /**
     * 
     * @type {number}
     * @memberof DashboardResponse
     */
    'contractsOpen': number;
    /**
     * 
     * @type {number}
     * @memberof DashboardResponse
     */
    'contractsFinished': number;
    /**
     * 
     * @type {number}
     * @memberof DashboardResponse
     */
    'todo': number;
    /**
     * 
     * @type {number}
     * @memberof DashboardResponse
     */
    'signed': number;
}
/**
 * 
 * @export
 * @interface DeclineContractDto
 */
export interface DeclineContractDto {
    /**
     * 
     * @type {string}
     * @memberof DeclineContractDto
     */
    'secret': string;
    /**
     * 
     * @type {string}
     * @memberof DeclineContractDto
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface DelegateContractDto
 */
export interface DelegateContractDto {
    /**
     * 
     * @type {string}
     * @memberof DelegateContractDto
     */
    'secret': string;
    /**
     * 
     * @type {string}
     * @memberof DelegateContractDto
     */
    'user': string;
}
/**
 * 
 * @export
 * @interface EndPointResponse
 */
export interface EndPointResponse {
    /**
     * 
     * @type {string}
     * @memberof EndPointResponse
     */
    'own': string;
    /**
     * 
     * @type {object}
     * @memberof EndPointResponse
     */
    'networks': object;
}
/**
 * 
 * @export
 * @interface Field
 */
export interface Field {
    /**
     * 
     * @type {number}
     * @memberof Field
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Field
     */
    'type': FieldTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Field
     */
    'userId': string;
    /**
     * 
     * @type {number}
     * @memberof Field
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof Field
     */
    'x': number;
    /**
     * 
     * @type {number}
     * @memberof Field
     */
    'y': number;
    /**
     * 
     * @type {number}
     * @memberof Field
     */
    'width': number;
    /**
     * 
     * @type {number}
     * @memberof Field
     */
    'height': number;
    /**
     * 
     * @type {string}
     * @memberof Field
     */
    'value'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum FieldTypeEnum {
    Signature = 'signature',
    Initials = 'initials',
    Qr = 'qr',
    Name = 'name',
    Town = 'town',
    Date = 'date'
}

/**
 * 
 * @export
 * @interface FileResponse
 */
export interface FileResponse {
    /**
     * 
     * @type {string}
     * @memberof FileResponse
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface FileUploadResponse
 */
export interface FileUploadResponse {
    /**
     * 
     * @type {string}
     * @memberof FileUploadResponse
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface ImageResponse
 */
export interface ImageResponse {
    /**
     * 
     * @type {string}
     * @memberof ImageResponse
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface ImagesResponse
 */
export interface ImagesResponse {
    /**
     * 
     * @type {string}
     * @memberof ImagesResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ImagesResponse
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof ImagesResponse
     */
    'image': string;
    /**
     * 
     * @type {string}
     * @memberof ImagesResponse
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface Information
 */
export interface Information {
    /**
     * 
     * @type {string}
     * @memberof Information
     */
    'prename'?: string;
    /**
     * 
     * @type {string}
     * @memberof Information
     */
    'surname'?: string;
}
/**
 * 
 * @export
 * @interface Input
 */
export interface Input {
    /**
     * 
     * @type {User}
     * @memberof Input
     */
    'user': User;
    /**
     * 
     * @type {string}
     * @memberof Input
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof Input
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface JobRequest
 */
export interface JobRequest {
    /**
     * 
     * @type {object}
     * @memberof JobRequest
     */
    'transaction': object;
    /**
     * 
     * @type {string}
     * @memberof JobRequest
     */
    'endpoint': string;
}
/**
 * 
 * @export
 * @interface KeyPair
 */
export interface KeyPair {
    /**
     * 
     * @type {string}
     * @memberof KeyPair
     */
    'identifier': string;
    /**
     * 
     * @type {object}
     * @memberof KeyPair
     */
    'publicKey': object;
    /**
     * 
     * @type {string}
     * @memberof KeyPair
     */
    'privateKey': string;
    /**
     * 
     * @type {SignatureType}
     * @memberof KeyPair
     */
    'signatureType': SignatureType;
}
/**
 * 
 * @export
 * @interface LoginDto
 */
export interface LoginDto {
    /**
     * 
     * @type {string}
     * @memberof LoginDto
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof LoginDto
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface LoginResponse
 */
export interface LoginResponse {
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface Participant
 */
export interface Participant {
    /**
     * 
     * @type {string}
     * @memberof Participant
     */
    'role': ParticipantRoleEnum;
    /**
     * 
     * @type {Array<ContractInput>}
     * @memberof Participant
     */
    'values'?: Array<ContractInput>;
    /**
     * 
     * @type {string}
     * @memberof Participant
     */
    'secret'?: string;
    /**
     * 
     * @type {string}
     * @memberof Participant
     */
    'signed'?: string;
    /**
     * 
     * @type {string}
     * @memberof Participant
     */
    'declined'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Participant
     */
    'unsub': boolean;
    /**
     * 
     * @type {string}
     * @memberof Participant
     */
    'userId': string;
    /**
     * 
     * @type {Array<Field>}
     * @memberof Participant
     */
    'fields'?: Array<Field>;
}

/**
    * @export
    * @enum {string}
    */
export enum ParticipantRoleEnum {
    Signer = 'signer',
    Cc = 'cc',
    System = 'system'
}

/**
 * 
 * @export
 * @interface PdfRequest
 */
export interface PdfRequest {
    /**
     * 
     * @type {string}
     * @memberof PdfRequest
     */
    'html': string;
}
/**
 * 
 * @export
 * @interface PostCredential
 */
export interface PostCredential {
    /**
     * 
     * @type {object}
     * @memberof PostCredential
     */
    'values': object;
}
/**
 * 
 * @export
 * @interface PushKey
 */
export interface PushKey {
    /**
     * 
     * @type {string}
     * @memberof PushKey
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface PushSubKeys
 */
export interface PushSubKeys {
    /**
     * 
     * @type {string}
     * @memberof PushSubKeys
     */
    'p256dh': string;
    /**
     * 
     * @type {string}
     * @memberof PushSubKeys
     */
    'auth': string;
}
/**
 * 
 * @export
 * @interface PushSubscription
 */
export interface PushSubscription {
    /**
     * 
     * @type {string}
     * @memberof PushSubscription
     */
    'endpoint': string;
    /**
     * 
     * @type {number}
     * @memberof PushSubscription
     */
    'expirationTime': number;
    /**
     * 
     * @type {PushSubKeys}
     * @memberof PushSubscription
     */
    'keys': PushSubKeys;
}
/**
 * 
 * @export
 * @interface PushUnsubscribe
 */
export interface PushUnsubscribe {
    /**
     * 
     * @type {string}
     * @memberof PushUnsubscribe
     */
    'endpoint': string;
}
/**
 * 
 * @export
 * @interface RegisterDto
 */
export interface RegisterDto {
    /**
     * username of the account
     * @type {string}
     * @memberof RegisterDto
     */
    'username': string;
    /**
     * random encoded buffer that is used for salting
     * @type {string}
     * @memberof RegisterDto
     */
    'salt'?: string;
    /**
     * 
     * @type {RegistryRolesDto}
     * @memberof RegisterDto
     */
    'roles'?: RegistryRolesDto;
}
/**
 * 
 * @export
 * @interface RegistryRolesDto
 */
export interface RegistryRolesDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof RegistryRolesDto
     */
    'roles': Array<RegistryRolesDtoRolesEnum>;
    /**
     * 
     * @type {string}
     * @memberof RegistryRolesDto
     */
    'hash': string;
}

/**
    * @export
    * @enum {string}
    */
export enum RegistryRolesDtoRolesEnum {
    Admin = 'admin',
    Contract = 'contract',
    ContractIssuer = 'contract.issuer',
    Credential = 'credential',
    Training = 'training',
    TrainingConsultant = 'training.consultant',
    TrainingTaxConsultant = 'training.taxConsultant',
    TrainingManager = 'training.manager',
    Manager = 'manager',
    Member = 'member'
}

/**
 * 
 * @export
 * @interface RequestLinkDto
 */
export interface RequestLinkDto {
    /**
     * 
     * @type {string}
     * @memberof RequestLinkDto
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface ResolveResponse
 */
export interface ResolveResponse {
    /**
     * 
     * @type {string}
     * @memberof ResolveResponse
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof ResolveResponse
     */
    'iv': string;
}
/**
 * 
 * @export
 * @interface S3FileResponse
 */
export interface S3FileResponse {
    /**
     * 
     * @type {string}
     * @memberof S3FileResponse
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface SaltResponse
 */
export interface SaltResponse {
    /**
     * 
     * @type {string}
     * @memberof SaltResponse
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface ShortenDto
 */
export interface ShortenDto {
    /**
     * 
     * @type {string}
     * @memberof ShortenDto
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof ShortenDto
     */
    'iv': string;
}
/**
 * 
 * @export
 * @interface ShortenResponse
 */
export interface ShortenResponse {
    /**
     * 
     * @type {string}
     * @memberof ShortenResponse
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface SignContractDto
 */
export interface SignContractDto {
    /**
     * 
     * @type {string}
     * @memberof SignContractDto
     */
    'secret': string;
    /**
     * 
     * @type {Array<ContractInput>}
     * @memberof SignContractDto
     */
    'fields': Array<ContractInput>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum SignatureType {
    Rsa = 'RSA',
    Bbs = 'BBS+'
}

/**
 * 
 * @export
 * @interface Stakeholder
 */
export interface Stakeholder {
    /**
     * 
     * @type {string}
     * @memberof Stakeholder
     */
    'userId': string;
    /**
     * 
     * @type {Array<Field>}
     * @memberof Stakeholder
     */
    'fields'?: Array<Field>;
}
/**
 * 
 * @export
 * @interface Template
 */
export interface Template {
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    'did': string;
    /**
     * 
     * @type {CredentialValidationSchema}
     * @memberof Template
     */
    'schema': CredentialValidationSchema;
    /**
     * 
     * @type {User}
     * @memberof Template
     */
    'user': User;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    'verifier': string;
}
/**
 * 
 * @export
 * @interface Training
 */
export interface Training {
    /**
     * 
     * @type {string}
     * @memberof Training
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof Training
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof Training
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof Training
     */
    'duration': number;
    /**
     * 
     * @type {string}
     * @memberof Training
     */
    'notice': string;
    /**
     * 
     * @type {boolean}
     * @memberof Training
     */
    'specific'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Training
     */
    'random': string;
    /**
     * 
     * @type {string}
     * @memberof Training
     */
    'fileId': string;
    /**
     * 
     * @type {User}
     * @memberof Training
     */
    'user': User;
    /**
     * 
     * @type {string}
     * @memberof Training
     */
    'hash': string;
}
/**
 * 
 * @export
 * @interface UnsubContractDto
 */
export interface UnsubContractDto {
    /**
     * 
     * @type {string}
     * @memberof UnsubContractDto
     */
    'secret': string;
}
/**
 * 
 * @export
 * @interface UpdatePasswordDto
 */
export interface UpdatePasswordDto {
    /**
     * old password
     * @type {string}
     * @memberof UpdatePasswordDto
     */
    'oldPassword': string;
    /**
     * new password
     * @type {string}
     * @memberof UpdatePasswordDto
     */
    'newPassword': string;
    /**
     * new encrypted key
     * @type {string}
     * @memberof UpdatePasswordDto
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {Array<UserRole>}
     * @memberof User
     */
    'roles': Array<UserRole>;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'salt': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'key': string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'verified': boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'deleted': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastLogin': string;
    /**
     * 
     * @type {Information}
     * @memberof User
     */
    'information': Information;
    /**
     * 
     * @type {Wallet}
     * @memberof User
     */
    'did': Wallet;
    /**
     * 
     * @type {Array<PushSubscription>}
     * @memberof User
     */
    'pushSubs': Array<PushSubscription>;
    /**
     * 
     * @type {UserView}
     * @memberof User
     */
    'userView': UserView;
    /**
     * 
     * @type {User}
     * @memberof User
     */
    'manager'?: User;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'inactive': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    'tutorial': Array<string>;
}
/**
 * 
 * @export
 * @interface UserContract
 */
export interface UserContract {
    /**
     * 
     * @type {string}
     * @memberof UserContract
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserContract
     */
    'role': UserContractRoleEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum UserContractRoleEnum {
    Signer = 'signer',
    Cc = 'cc',
    System = 'system'
}

/**
 * 
 * @export
 * @interface UserCreateDto
 */
export interface UserCreateDto {
    /**
     * prename
     * @type {string}
     * @memberof UserCreateDto
     */
    'prename'?: string;
    /**
     * surname
     * @type {string}
     * @memberof UserCreateDto
     */
    'surname'?: string;
    /**
     * username that the user uses to register
     * @type {string}
     * @memberof UserCreateDto
     */
    'username': string;
    /**
     * name of the manager that is responsible for this account
     * @type {string}
     * @memberof UserCreateDto
     */
    'manager'?: string;
    /**
     * 
     * @type {Array<UserRole>}
     * @memberof UserCreateDto
     */
    'roles': Array<UserRole>;
}
/**
 * 
 * @export
 * @interface UserExport
 */
export interface UserExport {
    /**
     * 
     * @type {string}
     * @memberof UserExport
     */
    'username': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserExport
     */
    'verified': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserExport
     */
    'instructions': Array<string>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum UserRole {
    Admin = 'admin',
    Contract = 'contract',
    ContractIssuer = 'contract.issuer',
    Credential = 'credential',
    Training = 'training',
    TrainingConsultant = 'training.consultant',
    TrainingTaxConsultant = 'training.taxConsultant',
    TrainingManager = 'training.manager',
    Manager = 'manager',
    Member = 'member'
}

/**
 * 
 * @export
 * @interface UserView
 */
export interface UserView {
    /**
     * 
     * @type {Array<string>}
     * @memberof UserView
     */
    'tableSettingsUser': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserView
     */
    'tableSettingsUserMobile': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserView
     */
    'tableSettingsHr': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserView
     */
    'tableSettingsHrMobile': Array<string>;
}
/**
 * 
 * @export
 * @interface VerifyDto
 */
export interface VerifyDto {
    /**
     * 
     * @type {string}
     * @memberof VerifyDto
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof VerifyDto
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof VerifyDto
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof VerifyDto
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface Wallet
 */
export interface Wallet {
    /**
     * 
     * @type {Array<KeyPair>}
     * @memberof Wallet
     */
    'wallet': Array<KeyPair>;
    /**
     * 
     * @type {string}
     * @memberof Wallet
     */
    'id': string;
}

/**
 * AccountsPlatformApi - axios parameter creator
 * @export
 */
export const AccountsPlatformApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Activate a user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerActivate: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountsControllerActivate', 'id', id)
            const localVarPath = `/accounts/{id}/activate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a user by adding an identifier to an username.
         * @param {UserCreateDto} userCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerCreate: async (userCreateDto: UserCreateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreateDto' is not null or undefined
            assertParamExists('accountsControllerCreate', 'userCreateDto', userCreateDto)
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deactivate a user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerDeactivate: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountsControllerDeactivate', 'id', id)
            const localVarPath = `/accounts/{id}/deactivate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountsControllerDelete', 'id', id)
            const localVarPath = `/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all user names and their manager.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns one specific user.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerGetOne: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountsControllerGetOne', 'id', id)
            const localVarPath = `/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a reset token for the password.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerResetPassword: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountsControllerResetPassword', 'id', id)
            const localVarPath = `/accounts/{id}/reset`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a user entity.
         * @param {string} id 
         * @param {UserCreateDto} userCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerUpdate: async (id: string, userCreateDto: UserCreateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountsControllerUpdate', 'id', id)
            // verify required parameter 'userCreateDto' is not null or undefined
            assertParamExists('accountsControllerUpdate', 'userCreateDto', userCreateDto)
            const localVarPath = `/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsPlatformApi - functional programming interface
 * @export
 */
export const AccountsPlatformApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsPlatformApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Activate a user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerActivate(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerActivate(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a user by adding an identifier to an username.
         * @param {UserCreateDto} userCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerCreate(userCreateDto: UserCreateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerCreate(userCreateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deactivate a user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerDeactivate(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerDeactivate(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes a user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns all user names and their manager.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns one specific user.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerGetOne(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerGetOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates a reset token for the password.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerResetPassword(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerResetPassword(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a user entity.
         * @param {string} id 
         * @param {UserCreateDto} userCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerUpdate(id: string, userCreateDto: UserCreateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerUpdate(id, userCreateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountsPlatformApi - factory interface
 * @export
 */
export const AccountsPlatformApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsPlatformApiFp(configuration)
    return {
        /**
         * 
         * @summary Activate a user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerActivate(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.accountsControllerActivate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a user by adding an identifier to an username.
         * @param {UserCreateDto} userCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerCreate(userCreateDto: UserCreateDto, options?: any): AxiosPromise<void> {
            return localVarFp.accountsControllerCreate(userCreateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deactivate a user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerDeactivate(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.accountsControllerDeactivate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.accountsControllerDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all user names and their manager.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerGetAll(options?: any): AxiosPromise<Array<User>> {
            return localVarFp.accountsControllerGetAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns one specific user.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerGetOne(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.accountsControllerGetOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a reset token for the password.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerResetPassword(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.accountsControllerResetPassword(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a user entity.
         * @param {string} id 
         * @param {UserCreateDto} userCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerUpdate(id: string, userCreateDto: UserCreateDto, options?: any): AxiosPromise<void> {
            return localVarFp.accountsControllerUpdate(id, userCreateDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsPlatformApi - object-oriented interface
 * @export
 * @class AccountsPlatformApi
 * @extends {BaseAPI}
 */
export class AccountsPlatformApi extends BaseAPI {
    /**
     * 
     * @summary Activate a user
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsPlatformApi
     */
    public accountsControllerActivate(id: string, options?: AxiosRequestConfig) {
        return AccountsPlatformApiFp(this.configuration).accountsControllerActivate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a user by adding an identifier to an username.
     * @param {UserCreateDto} userCreateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsPlatformApi
     */
    public accountsControllerCreate(userCreateDto: UserCreateDto, options?: AxiosRequestConfig) {
        return AccountsPlatformApiFp(this.configuration).accountsControllerCreate(userCreateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deactivate a user
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsPlatformApi
     */
    public accountsControllerDeactivate(id: string, options?: AxiosRequestConfig) {
        return AccountsPlatformApiFp(this.configuration).accountsControllerDeactivate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a user
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsPlatformApi
     */
    public accountsControllerDelete(id: string, options?: AxiosRequestConfig) {
        return AccountsPlatformApiFp(this.configuration).accountsControllerDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all user names and their manager.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsPlatformApi
     */
    public accountsControllerGetAll(options?: AxiosRequestConfig) {
        return AccountsPlatformApiFp(this.configuration).accountsControllerGetAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns one specific user.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsPlatformApi
     */
    public accountsControllerGetOne(id: string, options?: AxiosRequestConfig) {
        return AccountsPlatformApiFp(this.configuration).accountsControllerGetOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a reset token for the password.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsPlatformApi
     */
    public accountsControllerResetPassword(id: string, options?: AxiosRequestConfig) {
        return AccountsPlatformApiFp(this.configuration).accountsControllerResetPassword(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a user entity.
     * @param {string} id 
     * @param {UserCreateDto} userCreateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsPlatformApi
     */
    public accountsControllerUpdate(id: string, userCreateDto: UserCreateDto, options?: AxiosRequestConfig) {
        return AccountsPlatformApiFp(this.configuration).accountsControllerUpdate(id, userCreateDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthorizePlatformApi - axios parameter creator
 * @export
 */
export const AuthorizePlatformApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Updates the password.
         * @param {UpdatePasswordDto} updatePasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerChangePassword: async (updatePasswordDto: UpdatePasswordDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updatePasswordDto' is not null or undefined
            assertParamExists('authControllerChangePassword', 'updatePasswordDto', updatePasswordDto)
            const localVarPath = `/auth/change_password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePasswordDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logs a user into the system based on the auth guard
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin: async (loginDto: LoginDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginDto' is not null or undefined
            assertParamExists('authControllerLogin', 'loginDto', loginDto)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary registers a new account
         * @param {RegisterDto} registerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRegister: async (registerDto: RegisterDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerDto' is not null or undefined
            assertParamExists('authControllerRegister', 'registerDto', registerDto)
            const localVarPath = `/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sends an email to reset the password
         * @param {RequestLinkDto} requestLinkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRequestLink: async (requestLinkDto: RequestLinkDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestLinkDto' is not null or undefined
            assertParamExists('authControllerRequestLink', 'requestLinkDto', requestLinkDto)
            const localVarPath = `/auth/request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestLinkDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the salt of a user.
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSalt: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('authControllerSalt', 'username', username)
            const localVarPath = `/auth/salt/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sets a password for the account. Token required that was generated during registration
         * @param {VerifyDto} verifyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerVerify: async (verifyDto: VerifyDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifyDto' is not null or undefined
            assertParamExists('authControllerVerify', 'verifyDto', verifyDto)
            const localVarPath = `/auth/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthorizePlatformApi - functional programming interface
 * @export
 */
export const AuthorizePlatformApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthorizePlatformApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Updates the password.
         * @param {UpdatePasswordDto} updatePasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerChangePassword(updatePasswordDto: UpdatePasswordDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerChangePassword(updatePasswordDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Logs a user into the system based on the auth guard
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogin(loginDto: LoginDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogin(loginDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary registers a new account
         * @param {RegisterDto} registerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRegister(registerDto: RegisterDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRegister(registerDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Sends an email to reset the password
         * @param {RequestLinkDto} requestLinkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRequestLink(requestLinkDto: RequestLinkDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRequestLink(requestLinkDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns the salt of a user.
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerSalt(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SaltResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerSalt(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Sets a password for the account. Token required that was generated during registration
         * @param {VerifyDto} verifyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerVerify(verifyDto: VerifyDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerVerify(verifyDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthorizePlatformApi - factory interface
 * @export
 */
export const AuthorizePlatformApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthorizePlatformApiFp(configuration)
    return {
        /**
         * 
         * @summary Updates the password.
         * @param {UpdatePasswordDto} updatePasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerChangePassword(updatePasswordDto: UpdatePasswordDto, options?: any): AxiosPromise<void> {
            return localVarFp.authControllerChangePassword(updatePasswordDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logs a user into the system based on the auth guard
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin(loginDto: LoginDto, options?: any): AxiosPromise<LoginResponse> {
            return localVarFp.authControllerLogin(loginDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary registers a new account
         * @param {RegisterDto} registerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRegister(registerDto: RegisterDto, options?: any): AxiosPromise<void> {
            return localVarFp.authControllerRegister(registerDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sends an email to reset the password
         * @param {RequestLinkDto} requestLinkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRequestLink(requestLinkDto: RequestLinkDto, options?: any): AxiosPromise<object> {
            return localVarFp.authControllerRequestLink(requestLinkDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the salt of a user.
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSalt(username: string, options?: any): AxiosPromise<SaltResponse> {
            return localVarFp.authControllerSalt(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sets a password for the account. Token required that was generated during registration
         * @param {VerifyDto} verifyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerVerify(verifyDto: VerifyDto, options?: any): AxiosPromise<void> {
            return localVarFp.authControllerVerify(verifyDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthorizePlatformApi - object-oriented interface
 * @export
 * @class AuthorizePlatformApi
 * @extends {BaseAPI}
 */
export class AuthorizePlatformApi extends BaseAPI {
    /**
     * 
     * @summary Updates the password.
     * @param {UpdatePasswordDto} updatePasswordDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizePlatformApi
     */
    public authControllerChangePassword(updatePasswordDto: UpdatePasswordDto, options?: AxiosRequestConfig) {
        return AuthorizePlatformApiFp(this.configuration).authControllerChangePassword(updatePasswordDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logs a user into the system based on the auth guard
     * @param {LoginDto} loginDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizePlatformApi
     */
    public authControllerLogin(loginDto: LoginDto, options?: AxiosRequestConfig) {
        return AuthorizePlatformApiFp(this.configuration).authControllerLogin(loginDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary registers a new account
     * @param {RegisterDto} registerDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizePlatformApi
     */
    public authControllerRegister(registerDto: RegisterDto, options?: AxiosRequestConfig) {
        return AuthorizePlatformApiFp(this.configuration).authControllerRegister(registerDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sends an email to reset the password
     * @param {RequestLinkDto} requestLinkDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizePlatformApi
     */
    public authControllerRequestLink(requestLinkDto: RequestLinkDto, options?: AxiosRequestConfig) {
        return AuthorizePlatformApiFp(this.configuration).authControllerRequestLink(requestLinkDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the salt of a user.
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizePlatformApi
     */
    public authControllerSalt(username: string, options?: AxiosRequestConfig) {
        return AuthorizePlatformApiFp(this.configuration).authControllerSalt(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sets a password for the account. Token required that was generated during registration
     * @param {VerifyDto} verifyDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizePlatformApi
     */
    public authControllerVerify(verifyDto: VerifyDto, options?: AxiosRequestConfig) {
        return AuthorizePlatformApiFp(this.configuration).authControllerVerify(verifyDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BlockchainPlatformApi - axios parameter creator
 * @export
 */
export const BlockchainPlatformApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns the endpoints of the observer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockchainControllerEndpoints: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/blockchain/endpoints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a transaction to the queue
         * @param {JobRequest} jobRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockchainControllerJob: async (jobRequest: JobRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobRequest' is not null or undefined
            assertParamExists('blockchainControllerJob', 'jobRequest', jobRequest)
            const localVarPath = `/blockchain/job`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jobRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlockchainPlatformApi - functional programming interface
 * @export
 */
export const BlockchainPlatformApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BlockchainPlatformApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns the endpoints of the observer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blockchainControllerEndpoints(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EndPointResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blockchainControllerEndpoints(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Adds a transaction to the queue
         * @param {JobRequest} jobRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blockchainControllerJob(jobRequest: JobRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blockchainControllerJob(jobRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BlockchainPlatformApi - factory interface
 * @export
 */
export const BlockchainPlatformApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BlockchainPlatformApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns the endpoints of the observer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockchainControllerEndpoints(options?: any): AxiosPromise<EndPointResponse> {
            return localVarFp.blockchainControllerEndpoints(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds a transaction to the queue
         * @param {JobRequest} jobRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockchainControllerJob(jobRequest: JobRequest, options?: any): AxiosPromise<void> {
            return localVarFp.blockchainControllerJob(jobRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BlockchainPlatformApi - object-oriented interface
 * @export
 * @class BlockchainPlatformApi
 * @extends {BaseAPI}
 */
export class BlockchainPlatformApi extends BaseAPI {
    /**
     * 
     * @summary Returns the endpoints of the observer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockchainPlatformApi
     */
    public blockchainControllerEndpoints(options?: AxiosRequestConfig) {
        return BlockchainPlatformApiFp(this.configuration).blockchainControllerEndpoints(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds a transaction to the queue
     * @param {JobRequest} jobRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockchainPlatformApi
     */
    public blockchainControllerJob(jobRequest: JobRequest, options?: AxiosRequestConfig) {
        return BlockchainPlatformApiFp(this.configuration).blockchainControllerJob(jobRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContractsPlatformApi - axios parameter creator
 * @export
 */
export const ContractsPlatformApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {SignContractDto} signContractDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerAddSignature: async (id: string, signContractDto: SignContractDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('contractsControllerAddSignature', 'id', id)
            // verify required parameter 'signContractDto' is not null or undefined
            assertParamExists('contractsControllerAddSignature', 'signContractDto', signContractDto)
            const localVarPath = `/contracts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signContractDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the contacts to send the contract to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerContacts: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contracts/contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateContractDto} createContractDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerCreate: async (createContractDto: CreateContractDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createContractDto' is not null or undefined
            assertParamExists('contractsControllerCreate', 'createContractDto', createContractDto)
            const localVarPath = `/contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createContractDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerDashboard: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contracts/dashboard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {DeclineContractDto} declineContractDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerDeclineContract: async (id: string, declineContractDto: DeclineContractDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('contractsControllerDeclineContract', 'id', id)
            // verify required parameter 'declineContractDto' is not null or undefined
            assertParamExists('contractsControllerDeclineContract', 'declineContractDto', declineContractDto)
            const localVarPath = `/contracts/{id}/decline`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(declineContractDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {DelegateContractDto} delegateContractDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerDelegateContract: async (id: string, delegateContractDto: DelegateContractDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('contractsControllerDelegateContract', 'id', id)
            // verify required parameter 'delegateContractDto' is not null or undefined
            assertParamExists('contractsControllerDelegateContract', 'delegateContractDto', delegateContractDto)
            const localVarPath = `/contracts/{id}/delegate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(delegateContractDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary download the pdf file
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerDownloadFile: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('contractsControllerDownloadFile', 'id', id)
            const localVarPath = `/contracts/file/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary download a signed file with included fields
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerDownloadPdfFile: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('contractsControllerDownloadPdfFile', 'id', id)
            const localVarPath = `/contracts/{id}/pdf`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [signId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerFindOne: async (id: string, signId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('contractsControllerFindOne', 'id', id)
            const localVarPath = `/contracts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (signId !== undefined) {
                localVarQueryParameter['signId'] = signId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerGetInputs: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contracts/inputs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerInbox: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contracts/inbox`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerOwn: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contracts/own`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerRemindContract: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('contractsControllerRemindContract', 'id', id)
            const localVarPath = `/contracts/{id}/remind`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerRemove: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('contractsControllerRemove', 'id', id)
            const localVarPath = `/contracts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateInputDto} createInputDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerSetInput: async (createInputDto: CreateInputDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createInputDto' is not null or undefined
            assertParamExists('contractsControllerSetInput', 'createInputDto', createInputDto)
            const localVarPath = `/contracts/input`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createInputDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UnsubContractDto} unsubContractDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerUnsubContract: async (id: string, unsubContractDto: UnsubContractDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('contractsControllerUnsubContract', 'id', id)
            // verify required parameter 'unsubContractDto' is not null or undefined
            assertParamExists('contractsControllerUnsubContract', 'unsubContractDto', unsubContractDto)
            const localVarPath = `/contracts/{id}/unsub`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unsubContractDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {any} file file that should be signed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerUploadFile: async (file: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('contractsControllerUploadFile', 'file', file)
            const localVarPath = `/contracts/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContractsPlatformApi - functional programming interface
 * @export
 */
export const ContractsPlatformApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContractsPlatformApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {SignContractDto} signContractDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsControllerAddSignature(id: string, signContractDto: SignContractDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsControllerAddSignature(id, signContractDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary returns the contacts to send the contract to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsControllerContacts(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsControllerContacts(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateContractDto} createContractDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsControllerCreate(createContractDto: CreateContractDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateContractResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsControllerCreate(createContractDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsControllerDashboard(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsControllerDashboard(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {DeclineContractDto} declineContractDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsControllerDeclineContract(id: string, declineContractDto: DeclineContractDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsControllerDeclineContract(id, declineContractDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {DelegateContractDto} delegateContractDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsControllerDelegateContract(id: string, delegateContractDto: DelegateContractDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsControllerDelegateContract(id, delegateContractDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary download the pdf file
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsControllerDownloadFile(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<S3FileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsControllerDownloadFile(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary download a signed file with included fields
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsControllerDownloadPdfFile(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsControllerDownloadPdfFile(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [signId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsControllerFindOne(id: string, signId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contract>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsControllerFindOne(id, signId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsControllerGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Contract>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsControllerGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsControllerGetInputs(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Input>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsControllerGetInputs(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsControllerInbox(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Contract>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsControllerInbox(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsControllerOwn(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Contract>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsControllerOwn(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsControllerRemindContract(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsControllerRemindContract(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsControllerRemove(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsControllerRemove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateInputDto} createInputDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsControllerSetInput(createInputDto: CreateInputDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsControllerSetInput(createInputDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {UnsubContractDto} unsubContractDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsControllerUnsubContract(id: string, unsubContractDto: UnsubContractDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsControllerUnsubContract(id, unsubContractDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {any} file file that should be signed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsControllerUploadFile(file: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileUploadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsControllerUploadFile(file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContractsPlatformApi - factory interface
 * @export
 */
export const ContractsPlatformApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContractsPlatformApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {SignContractDto} signContractDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerAddSignature(id: string, signContractDto: SignContractDto, options?: any): AxiosPromise<void> {
            return localVarFp.contractsControllerAddSignature(id, signContractDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the contacts to send the contract to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerContacts(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.contractsControllerContacts(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateContractDto} createContractDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerCreate(createContractDto: CreateContractDto, options?: any): AxiosPromise<CreateContractResponse> {
            return localVarFp.contractsControllerCreate(createContractDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerDashboard(options?: any): AxiosPromise<DashboardResponse> {
            return localVarFp.contractsControllerDashboard(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {DeclineContractDto} declineContractDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerDeclineContract(id: string, declineContractDto: DeclineContractDto, options?: any): AxiosPromise<void> {
            return localVarFp.contractsControllerDeclineContract(id, declineContractDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {DelegateContractDto} delegateContractDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerDelegateContract(id: string, delegateContractDto: DelegateContractDto, options?: any): AxiosPromise<void> {
            return localVarFp.contractsControllerDelegateContract(id, delegateContractDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary download the pdf file
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerDownloadFile(id: string, options?: any): AxiosPromise<S3FileResponse> {
            return localVarFp.contractsControllerDownloadFile(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary download a signed file with included fields
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerDownloadPdfFile(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.contractsControllerDownloadPdfFile(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [signId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerFindOne(id: string, signId?: string, options?: any): AxiosPromise<Contract> {
            return localVarFp.contractsControllerFindOne(id, signId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerGet(options?: any): AxiosPromise<Array<Contract>> {
            return localVarFp.contractsControllerGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerGetInputs(options?: any): AxiosPromise<Array<Input>> {
            return localVarFp.contractsControllerGetInputs(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerInbox(options?: any): AxiosPromise<Array<Contract>> {
            return localVarFp.contractsControllerInbox(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerOwn(options?: any): AxiosPromise<Array<Contract>> {
            return localVarFp.contractsControllerOwn(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerRemindContract(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.contractsControllerRemindContract(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerRemove(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.contractsControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateInputDto} createInputDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerSetInput(createInputDto: CreateInputDto, options?: any): AxiosPromise<void> {
            return localVarFp.contractsControllerSetInput(createInputDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UnsubContractDto} unsubContractDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerUnsubContract(id: string, unsubContractDto: UnsubContractDto, options?: any): AxiosPromise<void> {
            return localVarFp.contractsControllerUnsubContract(id, unsubContractDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {any} file file that should be signed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerUploadFile(file: any, options?: any): AxiosPromise<FileUploadResponse> {
            return localVarFp.contractsControllerUploadFile(file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContractsPlatformApi - object-oriented interface
 * @export
 * @class ContractsPlatformApi
 * @extends {BaseAPI}
 */
export class ContractsPlatformApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {SignContractDto} signContractDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsPlatformApi
     */
    public contractsControllerAddSignature(id: string, signContractDto: SignContractDto, options?: AxiosRequestConfig) {
        return ContractsPlatformApiFp(this.configuration).contractsControllerAddSignature(id, signContractDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the contacts to send the contract to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsPlatformApi
     */
    public contractsControllerContacts(options?: AxiosRequestConfig) {
        return ContractsPlatformApiFp(this.configuration).contractsControllerContacts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateContractDto} createContractDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsPlatformApi
     */
    public contractsControllerCreate(createContractDto: CreateContractDto, options?: AxiosRequestConfig) {
        return ContractsPlatformApiFp(this.configuration).contractsControllerCreate(createContractDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsPlatformApi
     */
    public contractsControllerDashboard(options?: AxiosRequestConfig) {
        return ContractsPlatformApiFp(this.configuration).contractsControllerDashboard(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {DeclineContractDto} declineContractDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsPlatformApi
     */
    public contractsControllerDeclineContract(id: string, declineContractDto: DeclineContractDto, options?: AxiosRequestConfig) {
        return ContractsPlatformApiFp(this.configuration).contractsControllerDeclineContract(id, declineContractDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {DelegateContractDto} delegateContractDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsPlatformApi
     */
    public contractsControllerDelegateContract(id: string, delegateContractDto: DelegateContractDto, options?: AxiosRequestConfig) {
        return ContractsPlatformApiFp(this.configuration).contractsControllerDelegateContract(id, delegateContractDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary download the pdf file
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsPlatformApi
     */
    public contractsControllerDownloadFile(id: string, options?: AxiosRequestConfig) {
        return ContractsPlatformApiFp(this.configuration).contractsControllerDownloadFile(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary download a signed file with included fields
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsPlatformApi
     */
    public contractsControllerDownloadPdfFile(id: string, options?: AxiosRequestConfig) {
        return ContractsPlatformApiFp(this.configuration).contractsControllerDownloadPdfFile(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} [signId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsPlatformApi
     */
    public contractsControllerFindOne(id: string, signId?: string, options?: AxiosRequestConfig) {
        return ContractsPlatformApiFp(this.configuration).contractsControllerFindOne(id, signId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsPlatformApi
     */
    public contractsControllerGet(options?: AxiosRequestConfig) {
        return ContractsPlatformApiFp(this.configuration).contractsControllerGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsPlatformApi
     */
    public contractsControllerGetInputs(options?: AxiosRequestConfig) {
        return ContractsPlatformApiFp(this.configuration).contractsControllerGetInputs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsPlatformApi
     */
    public contractsControllerInbox(options?: AxiosRequestConfig) {
        return ContractsPlatformApiFp(this.configuration).contractsControllerInbox(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsPlatformApi
     */
    public contractsControllerOwn(options?: AxiosRequestConfig) {
        return ContractsPlatformApiFp(this.configuration).contractsControllerOwn(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsPlatformApi
     */
    public contractsControllerRemindContract(id: string, options?: AxiosRequestConfig) {
        return ContractsPlatformApiFp(this.configuration).contractsControllerRemindContract(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsPlatformApi
     */
    public contractsControllerRemove(id: string, options?: AxiosRequestConfig) {
        return ContractsPlatformApiFp(this.configuration).contractsControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateInputDto} createInputDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsPlatformApi
     */
    public contractsControllerSetInput(createInputDto: CreateInputDto, options?: AxiosRequestConfig) {
        return ContractsPlatformApiFp(this.configuration).contractsControllerSetInput(createInputDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UnsubContractDto} unsubContractDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsPlatformApi
     */
    public contractsControllerUnsubContract(id: string, unsubContractDto: UnsubContractDto, options?: AxiosRequestConfig) {
        return ContractsPlatformApiFp(this.configuration).contractsControllerUnsubContract(id, unsubContractDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {any} file file that should be signed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsPlatformApi
     */
    public contractsControllerUploadFile(file: any, options?: AxiosRequestConfig) {
        return ContractsPlatformApiFp(this.configuration).contractsControllerUploadFile(file, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CredentialsPlatformApi - axios parameter creator
 * @export
 */
export const CredentialsPlatformApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateCredentialDto} createCredentialDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsControllerCreate: async (createCredentialDto: CreateCredentialDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCredentialDto' is not null or undefined
            assertParamExists('credentialsControllerCreate', 'createCredentialDto', createCredentialDto)
            const localVarPath = `/credentials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCredentialDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsControllerDeleteStore: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('credentialsControllerDeleteStore', 'id', id)
            const localVarPath = `/credentials/store/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsControllerFindAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/credentials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsControllerFindOne: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('credentialsControllerFindOne', 'id', id)
            const localVarPath = `/credentials/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsControllerGetStore: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('credentialsControllerGetStore', 'id', id)
            const localVarPath = `/credentials/store/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {PostCredential} postCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsControllerPutStore: async (id: string, postCredential: PostCredential, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('credentialsControllerPutStore', 'id', id)
            // verify required parameter 'postCredential' is not null or undefined
            assertParamExists('credentialsControllerPutStore', 'postCredential', postCredential)
            const localVarPath = `/credentials/store/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postCredential, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsControllerRemove: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('credentialsControllerRemove', 'id', id)
            const localVarPath = `/credentials/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PdfRequest} pdfRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsControllerToPdf: async (pdfRequest: PdfRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pdfRequest' is not null or undefined
            assertParamExists('credentialsControllerToPdf', 'pdfRequest', pdfRequest)
            const localVarPath = `/credentials/pdf`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pdfRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CredentialsPlatformApi - functional programming interface
 * @export
 */
export const CredentialsPlatformApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CredentialsPlatformApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateCredentialDto} createCredentialDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async credentialsControllerCreate(createCredentialDto: CreateCredentialDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.credentialsControllerCreate(createCredentialDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async credentialsControllerDeleteStore(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.credentialsControllerDeleteStore(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async credentialsControllerFindAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.credentialsControllerFindAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async credentialsControllerFindOne(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Template>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.credentialsControllerFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async credentialsControllerGetStore(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Credential>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.credentialsControllerGetStore(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {PostCredential} postCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async credentialsControllerPutStore(id: string, postCredential: PostCredential, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.credentialsControllerPutStore(id, postCredential, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async credentialsControllerRemove(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.credentialsControllerRemove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {PdfRequest} pdfRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async credentialsControllerToPdf(pdfRequest: PdfRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.credentialsControllerToPdf(pdfRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CredentialsPlatformApi - factory interface
 * @export
 */
export const CredentialsPlatformApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CredentialsPlatformApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateCredentialDto} createCredentialDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsControllerCreate(createCredentialDto: CreateCredentialDto, options?: any): AxiosPromise<void> {
            return localVarFp.credentialsControllerCreate(createCredentialDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsControllerDeleteStore(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.credentialsControllerDeleteStore(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsControllerFindAll(options?: any): AxiosPromise<void> {
            return localVarFp.credentialsControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsControllerFindOne(id: string, options?: any): AxiosPromise<Template> {
            return localVarFp.credentialsControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsControllerGetStore(id: string, options?: any): AxiosPromise<Array<Credential>> {
            return localVarFp.credentialsControllerGetStore(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {PostCredential} postCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsControllerPutStore(id: string, postCredential: PostCredential, options?: any): AxiosPromise<void> {
            return localVarFp.credentialsControllerPutStore(id, postCredential, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsControllerRemove(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.credentialsControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PdfRequest} pdfRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsControllerToPdf(pdfRequest: PdfRequest, options?: any): AxiosPromise<any> {
            return localVarFp.credentialsControllerToPdf(pdfRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CredentialsPlatformApi - object-oriented interface
 * @export
 * @class CredentialsPlatformApi
 * @extends {BaseAPI}
 */
export class CredentialsPlatformApi extends BaseAPI {
    /**
     * 
     * @param {CreateCredentialDto} createCredentialDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsPlatformApi
     */
    public credentialsControllerCreate(createCredentialDto: CreateCredentialDto, options?: AxiosRequestConfig) {
        return CredentialsPlatformApiFp(this.configuration).credentialsControllerCreate(createCredentialDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsPlatformApi
     */
    public credentialsControllerDeleteStore(id: string, options?: AxiosRequestConfig) {
        return CredentialsPlatformApiFp(this.configuration).credentialsControllerDeleteStore(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsPlatformApi
     */
    public credentialsControllerFindAll(options?: AxiosRequestConfig) {
        return CredentialsPlatformApiFp(this.configuration).credentialsControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsPlatformApi
     */
    public credentialsControllerFindOne(id: string, options?: AxiosRequestConfig) {
        return CredentialsPlatformApiFp(this.configuration).credentialsControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsPlatformApi
     */
    public credentialsControllerGetStore(id: string, options?: AxiosRequestConfig) {
        return CredentialsPlatformApiFp(this.configuration).credentialsControllerGetStore(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {PostCredential} postCredential 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsPlatformApi
     */
    public credentialsControllerPutStore(id: string, postCredential: PostCredential, options?: AxiosRequestConfig) {
        return CredentialsPlatformApiFp(this.configuration).credentialsControllerPutStore(id, postCredential, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsPlatformApi
     */
    public credentialsControllerRemove(id: string, options?: AxiosRequestConfig) {
        return CredentialsPlatformApiFp(this.configuration).credentialsControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PdfRequest} pdfRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsPlatformApi
     */
    public credentialsControllerToPdf(pdfRequest: PdfRequest, options?: AxiosRequestConfig) {
        return CredentialsPlatformApiFp(this.configuration).credentialsControllerToPdf(pdfRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ImagePlatformApi - axios parameter creator
 * @export
 */
export const ImagePlatformApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageControllerGetAllImages: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageControllerGetImageById: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageControllerGetImageById', 'id', id)
            const localVarPath = `/image/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageControllerRemoveImage: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageControllerRemoveImage', 'id', id)
            const localVarPath = `/image/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageControllerShowImageById: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageControllerShowImageById', 'id', id)
            const localVarPath = `/image/{id}/show`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {any} file file that should be signed
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageControllerUploadFile: async (file: any, name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('imageControllerUploadFile', 'file', file)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('imageControllerUploadFile', 'name', name)
            const localVarPath = `/image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImagePlatformApi - functional programming interface
 * @export
 */
export const ImagePlatformApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImagePlatformApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageControllerGetAllImages(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImagesResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageControllerGetAllImages(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageControllerGetImageById(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageControllerGetImageById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageControllerRemoveImage(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageControllerRemoveImage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageControllerShowImageById(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageControllerShowImageById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {any} file file that should be signed
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageControllerUploadFile(file: any, name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageControllerUploadFile(file, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ImagePlatformApi - factory interface
 * @export
 */
export const ImagePlatformApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImagePlatformApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageControllerGetAllImages(options?: any): AxiosPromise<Array<ImagesResponse>> {
            return localVarFp.imageControllerGetAllImages(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageControllerGetImageById(id: string, options?: any): AxiosPromise<ImageResponse> {
            return localVarFp.imageControllerGetImageById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageControllerRemoveImage(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.imageControllerRemoveImage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageControllerShowImageById(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.imageControllerShowImageById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {any} file file that should be signed
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageControllerUploadFile(file: any, name: string, options?: any): AxiosPromise<void> {
            return localVarFp.imageControllerUploadFile(file, name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImagePlatformApi - object-oriented interface
 * @export
 * @class ImagePlatformApi
 * @extends {BaseAPI}
 */
export class ImagePlatformApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagePlatformApi
     */
    public imageControllerGetAllImages(options?: AxiosRequestConfig) {
        return ImagePlatformApiFp(this.configuration).imageControllerGetAllImages(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagePlatformApi
     */
    public imageControllerGetImageById(id: string, options?: AxiosRequestConfig) {
        return ImagePlatformApiFp(this.configuration).imageControllerGetImageById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagePlatformApi
     */
    public imageControllerRemoveImage(id: string, options?: AxiosRequestConfig) {
        return ImagePlatformApiFp(this.configuration).imageControllerRemoveImage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagePlatformApi
     */
    public imageControllerShowImageById(id: string, options?: AxiosRequestConfig) {
        return ImagePlatformApiFp(this.configuration).imageControllerShowImageById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {any} file file that should be signed
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagePlatformApi
     */
    public imageControllerUploadFile(file: any, name: string, options?: AxiosRequestConfig) {
        return ImagePlatformApiFp(this.configuration).imageControllerUploadFile(file, name, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ManagerPlatformApi - axios parameter creator
 * @export
 */
export const ManagerPlatformApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets a specific employer of a manager
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        managerControllerFindEmployee: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('managerControllerFindEmployee', 'id', id)
            const localVarPath = `/manager/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all user from a manager
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        managerControllerFindEmployees: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/manager`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManagerPlatformApi - functional programming interface
 * @export
 */
export const ManagerPlatformApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManagerPlatformApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Gets a specific employer of a manager
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async managerControllerFindEmployee(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserExport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.managerControllerFindEmployee(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets all user from a manager
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async managerControllerFindEmployees(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserExport>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.managerControllerFindEmployees(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ManagerPlatformApi - factory interface
 * @export
 */
export const ManagerPlatformApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManagerPlatformApiFp(configuration)
    return {
        /**
         * 
         * @summary Gets a specific employer of a manager
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        managerControllerFindEmployee(id: string, options?: any): AxiosPromise<UserExport> {
            return localVarFp.managerControllerFindEmployee(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all user from a manager
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        managerControllerFindEmployees(options?: any): AxiosPromise<Array<UserExport>> {
            return localVarFp.managerControllerFindEmployees(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManagerPlatformApi - object-oriented interface
 * @export
 * @class ManagerPlatformApi
 * @extends {BaseAPI}
 */
export class ManagerPlatformApi extends BaseAPI {
    /**
     * 
     * @summary Gets a specific employer of a manager
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagerPlatformApi
     */
    public managerControllerFindEmployee(id: string, options?: AxiosRequestConfig) {
        return ManagerPlatformApiFp(this.configuration).managerControllerFindEmployee(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all user from a manager
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagerPlatformApi
     */
    public managerControllerFindEmployees(options?: AxiosRequestConfig) {
        return ManagerPlatformApiFp(this.configuration).managerControllerFindEmployees(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PushPlatformApi - axios parameter creator
 * @export
 */
export const PushPlatformApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary get the key of the endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushControllerGetKey: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/push`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary unsubscribe
         * @param {PushUnsubscribe} pushUnsubscribe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushControllerRemoveKey: async (pushUnsubscribe: PushUnsubscribe, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pushUnsubscribe' is not null or undefined
            assertParamExists('pushControllerRemoveKey', 'pushUnsubscribe', pushUnsubscribe)
            const localVarPath = `/push/unsub`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pushUnsubscribe, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary store the sub key
         * @param {PushSubscription} pushSubscription 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushControllerStoreKey: async (pushSubscription: PushSubscription, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pushSubscription' is not null or undefined
            assertParamExists('pushControllerStoreKey', 'pushSubscription', pushSubscription)
            const localVarPath = `/push/sub`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pushSubscription, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary test subs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushControllerTest: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/push/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PushPlatformApi - functional programming interface
 * @export
 */
export const PushPlatformApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PushPlatformApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary get the key of the endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pushControllerGetKey(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PushKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pushControllerGetKey(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary unsubscribe
         * @param {PushUnsubscribe} pushUnsubscribe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pushControllerRemoveKey(pushUnsubscribe: PushUnsubscribe, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pushControllerRemoveKey(pushUnsubscribe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary store the sub key
         * @param {PushSubscription} pushSubscription 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pushControllerStoreKey(pushSubscription: PushSubscription, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pushControllerStoreKey(pushSubscription, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary test subs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pushControllerTest(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pushControllerTest(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PushPlatformApi - factory interface
 * @export
 */
export const PushPlatformApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PushPlatformApiFp(configuration)
    return {
        /**
         * 
         * @summary get the key of the endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushControllerGetKey(options?: any): AxiosPromise<PushKey> {
            return localVarFp.pushControllerGetKey(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary unsubscribe
         * @param {PushUnsubscribe} pushUnsubscribe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushControllerRemoveKey(pushUnsubscribe: PushUnsubscribe, options?: any): AxiosPromise<void> {
            return localVarFp.pushControllerRemoveKey(pushUnsubscribe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary store the sub key
         * @param {PushSubscription} pushSubscription 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushControllerStoreKey(pushSubscription: PushSubscription, options?: any): AxiosPromise<void> {
            return localVarFp.pushControllerStoreKey(pushSubscription, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary test subs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushControllerTest(options?: any): AxiosPromise<void> {
            return localVarFp.pushControllerTest(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PushPlatformApi - object-oriented interface
 * @export
 * @class PushPlatformApi
 * @extends {BaseAPI}
 */
export class PushPlatformApi extends BaseAPI {
    /**
     * 
     * @summary get the key of the endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PushPlatformApi
     */
    public pushControllerGetKey(options?: AxiosRequestConfig) {
        return PushPlatformApiFp(this.configuration).pushControllerGetKey(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary unsubscribe
     * @param {PushUnsubscribe} pushUnsubscribe 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PushPlatformApi
     */
    public pushControllerRemoveKey(pushUnsubscribe: PushUnsubscribe, options?: AxiosRequestConfig) {
        return PushPlatformApiFp(this.configuration).pushControllerRemoveKey(pushUnsubscribe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary store the sub key
     * @param {PushSubscription} pushSubscription 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PushPlatformApi
     */
    public pushControllerStoreKey(pushSubscription: PushSubscription, options?: AxiosRequestConfig) {
        return PushPlatformApiFp(this.configuration).pushControllerStoreKey(pushSubscription, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary test subs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PushPlatformApi
     */
    public pushControllerTest(options?: AxiosRequestConfig) {
        return PushPlatformApiFp(this.configuration).pushControllerTest(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettingsPlatformApi - axios parameter creator
 * @export
 */
export const SettingsPlatformApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsControllerGetInformation: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/information`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary gets the values of the tutorial settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsControllerGetTutorial: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/tutorial`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the encrypted config of a client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsControllerGetWallet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/wallet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary stores the values of the tutorial settings
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsControllerPostTutorial: async (requestBody: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('settingsControllerPostTutorial', 'requestBody', requestBody)
            const localVarPath = `/settings/tutorial`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AccountInformation} accountInformation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsControllerSetInformation: async (accountInformation: AccountInformation, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountInformation' is not null or undefined
            assertParamExists('settingsControllerSetInformation', 'accountInformation', accountInformation)
            const localVarPath = `/settings/information`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountInformation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stores the encrypted config of a client
         * @param {Wallet} wallet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsControllerSetWallet: async (wallet: Wallet, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'wallet' is not null or undefined
            assertParamExists('settingsControllerSetWallet', 'wallet', wallet)
            const localVarPath = `/settings/wallet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(wallet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsPlatformApi - functional programming interface
 * @export
 */
export const SettingsPlatformApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsPlatformApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsControllerGetInformation(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Information>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsControllerGetInformation(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary gets the values of the tutorial settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsControllerGetTutorial(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsControllerGetTutorial(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns the encrypted config of a client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsControllerGetWallet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Wallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsControllerGetWallet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary stores the values of the tutorial settings
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsControllerPostTutorial(requestBody: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsControllerPostTutorial(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {AccountInformation} accountInformation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsControllerSetInformation(accountInformation: AccountInformation, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsControllerSetInformation(accountInformation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Stores the encrypted config of a client
         * @param {Wallet} wallet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsControllerSetWallet(wallet: Wallet, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsControllerSetWallet(wallet, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettingsPlatformApi - factory interface
 * @export
 */
export const SettingsPlatformApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsPlatformApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsControllerGetInformation(options?: any): AxiosPromise<Information> {
            return localVarFp.settingsControllerGetInformation(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary gets the values of the tutorial settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsControllerGetTutorial(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.settingsControllerGetTutorial(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the encrypted config of a client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsControllerGetWallet(options?: any): AxiosPromise<Wallet> {
            return localVarFp.settingsControllerGetWallet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary stores the values of the tutorial settings
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsControllerPostTutorial(requestBody: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.settingsControllerPostTutorial(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccountInformation} accountInformation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsControllerSetInformation(accountInformation: AccountInformation, options?: any): AxiosPromise<void> {
            return localVarFp.settingsControllerSetInformation(accountInformation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stores the encrypted config of a client
         * @param {Wallet} wallet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsControllerSetWallet(wallet: Wallet, options?: any): AxiosPromise<void> {
            return localVarFp.settingsControllerSetWallet(wallet, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsPlatformApi - object-oriented interface
 * @export
 * @class SettingsPlatformApi
 * @extends {BaseAPI}
 */
export class SettingsPlatformApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsPlatformApi
     */
    public settingsControllerGetInformation(options?: AxiosRequestConfig) {
        return SettingsPlatformApiFp(this.configuration).settingsControllerGetInformation(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary gets the values of the tutorial settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsPlatformApi
     */
    public settingsControllerGetTutorial(options?: AxiosRequestConfig) {
        return SettingsPlatformApiFp(this.configuration).settingsControllerGetTutorial(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the encrypted config of a client
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsPlatformApi
     */
    public settingsControllerGetWallet(options?: AxiosRequestConfig) {
        return SettingsPlatformApiFp(this.configuration).settingsControllerGetWallet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary stores the values of the tutorial settings
     * @param {Array<string>} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsPlatformApi
     */
    public settingsControllerPostTutorial(requestBody: Array<string>, options?: AxiosRequestConfig) {
        return SettingsPlatformApiFp(this.configuration).settingsControllerPostTutorial(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccountInformation} accountInformation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsPlatformApi
     */
    public settingsControllerSetInformation(accountInformation: AccountInformation, options?: AxiosRequestConfig) {
        return SettingsPlatformApiFp(this.configuration).settingsControllerSetInformation(accountInformation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stores the encrypted config of a client
     * @param {Wallet} wallet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsPlatformApi
     */
    public settingsControllerSetWallet(wallet: Wallet, options?: AxiosRequestConfig) {
        return SettingsPlatformApiFp(this.configuration).settingsControllerSetWallet(wallet, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ShortenPlatformApi - axios parameter creator
 * @export
 */
export const ShortenPlatformApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shortenControllerResolve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('shortenControllerResolve', 'id', id)
            const localVarPath = `/shorten/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ShortenDto} shortenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shortenControllerShorten: async (shortenDto: ShortenDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shortenDto' is not null or undefined
            assertParamExists('shortenControllerShorten', 'shortenDto', shortenDto)
            const localVarPath = `/shorten`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shortenDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShortenPlatformApi - functional programming interface
 * @export
 */
export const ShortenPlatformApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShortenPlatformApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shortenControllerResolve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResolveResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shortenControllerResolve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ShortenDto} shortenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shortenControllerShorten(shortenDto: ShortenDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShortenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shortenControllerShorten(shortenDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ShortenPlatformApi - factory interface
 * @export
 */
export const ShortenPlatformApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShortenPlatformApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shortenControllerResolve(id: string, options?: any): AxiosPromise<ResolveResponse> {
            return localVarFp.shortenControllerResolve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ShortenDto} shortenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shortenControllerShorten(shortenDto: ShortenDto, options?: any): AxiosPromise<ShortenResponse> {
            return localVarFp.shortenControllerShorten(shortenDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShortenPlatformApi - object-oriented interface
 * @export
 * @class ShortenPlatformApi
 * @extends {BaseAPI}
 */
export class ShortenPlatformApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShortenPlatformApi
     */
    public shortenControllerResolve(id: string, options?: AxiosRequestConfig) {
        return ShortenPlatformApiFp(this.configuration).shortenControllerResolve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ShortenDto} shortenDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShortenPlatformApi
     */
    public shortenControllerShorten(shortenDto: ShortenDto, options?: AxiosRequestConfig) {
        return ShortenPlatformApiFp(this.configuration).shortenControllerShorten(shortenDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StripePlatformApi - axios parameter creator
 * @export
 */
export const StripePlatformApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payControllerCreateCheckoutSession: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stripe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payControllerHasPay: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stripe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payControllerPortal: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stripe/portal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payControllerWebhook: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stripe/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StripePlatformApi - functional programming interface
 * @export
 */
export const StripePlatformApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StripePlatformApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payControllerCreateCheckoutSession(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payControllerCreateCheckoutSession(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payControllerHasPay(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payControllerHasPay(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payControllerPortal(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payControllerPortal(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payControllerWebhook(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payControllerWebhook(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StripePlatformApi - factory interface
 * @export
 */
export const StripePlatformApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StripePlatformApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payControllerCreateCheckoutSession(options?: any): AxiosPromise<object> {
            return localVarFp.payControllerCreateCheckoutSession(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payControllerHasPay(options?: any): AxiosPromise<void> {
            return localVarFp.payControllerHasPay(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payControllerPortal(options?: any): AxiosPromise<void> {
            return localVarFp.payControllerPortal(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payControllerWebhook(options?: any): AxiosPromise<void> {
            return localVarFp.payControllerWebhook(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StripePlatformApi - object-oriented interface
 * @export
 * @class StripePlatformApi
 * @extends {BaseAPI}
 */
export class StripePlatformApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripePlatformApi
     */
    public payControllerCreateCheckoutSession(options?: AxiosRequestConfig) {
        return StripePlatformApiFp(this.configuration).payControllerCreateCheckoutSession(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripePlatformApi
     */
    public payControllerHasPay(options?: AxiosRequestConfig) {
        return StripePlatformApiFp(this.configuration).payControllerHasPay(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripePlatformApi
     */
    public payControllerPortal(options?: AxiosRequestConfig) {
        return StripePlatformApiFp(this.configuration).payControllerPortal(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripePlatformApi
     */
    public payControllerWebhook(options?: AxiosRequestConfig) {
        return StripePlatformApiFp(this.configuration).payControllerWebhook(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TemplatecontractPlatformApi - axios parameter creator
 * @export
 */
export const TemplatecontractPlatformApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateControllerAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/template`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateControllerDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('templateControllerDelete', 'id', id)
            const localVarPath = `/template/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateControllerGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('templateControllerGet', 'id', id)
            const localVarPath = `/template/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateTemplate} createTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateControllerStore: async (createTemplate: CreateTemplate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTemplate' is not null or undefined
            assertParamExists('templateControllerStore', 'createTemplate', createTemplate)
            const localVarPath = `/template`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTemplate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplatecontractPlatformApi - functional programming interface
 * @export
 */
export const TemplatecontractPlatformApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TemplatecontractPlatformApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templateControllerAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ContractTemplate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templateControllerAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templateControllerDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templateControllerDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templateControllerGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templateControllerGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateTemplate} createTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templateControllerStore(createTemplate: CreateTemplate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templateControllerStore(createTemplate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TemplatecontractPlatformApi - factory interface
 * @export
 */
export const TemplatecontractPlatformApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TemplatecontractPlatformApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateControllerAll(options?: any): AxiosPromise<Array<ContractTemplate>> {
            return localVarFp.templateControllerAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateControllerDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.templateControllerDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateControllerGet(id: string, options?: any): AxiosPromise<ContractTemplate> {
            return localVarFp.templateControllerGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateTemplate} createTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateControllerStore(createTemplate: CreateTemplate, options?: any): AxiosPromise<void> {
            return localVarFp.templateControllerStore(createTemplate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TemplatecontractPlatformApi - object-oriented interface
 * @export
 * @class TemplatecontractPlatformApi
 * @extends {BaseAPI}
 */
export class TemplatecontractPlatformApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatecontractPlatformApi
     */
    public templateControllerAll(options?: AxiosRequestConfig) {
        return TemplatecontractPlatformApiFp(this.configuration).templateControllerAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatecontractPlatformApi
     */
    public templateControllerDelete(id: string, options?: AxiosRequestConfig) {
        return TemplatecontractPlatformApiFp(this.configuration).templateControllerDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatecontractPlatformApi
     */
    public templateControllerGet(id: string, options?: AxiosRequestConfig) {
        return TemplatecontractPlatformApiFp(this.configuration).templateControllerGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateTemplate} createTemplate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatecontractPlatformApi
     */
    public templateControllerStore(createTemplate: CreateTemplate, options?: AxiosRequestConfig) {
        return TemplatecontractPlatformApiFp(this.configuration).templateControllerStore(createTemplate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TrainingPlatformApi - axios parameter creator
 * @export
 */
export const TrainingPlatformApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds a new training
         * @param {Training} training 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingControllerAddTraining: async (training: Training, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'training' is not null or undefined
            assertParamExists('trainingControllerAddTraining', 'training', training)
            const localVarPath = `/training`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(training, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a training
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingControllerDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('trainingControllerDelete', 'id', id)
            const localVarPath = `/training/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the file of a training
         * @param {string} trainingid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingControllerFile: async (trainingid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trainingid' is not null or undefined
            assertParamExists('trainingControllerFile', 'trainingid', trainingid)
            const localVarPath = `/training/{trainingid}/file`
                .replace(`{${"trainingid"}}`, encodeURIComponent(String(trainingid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all managed accounts of the logged in user.
         * @param {string} [manager] returns the users of a specific manager
         * @param {string} [all] return all users
         * @param {number} [year] timespawn of the claims
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingControllerGetAllUsers: async (manager?: string, all?: string, year?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/training/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (manager !== undefined) {
                localVarQueryParameter['manager'] = manager;
            }

            if (all !== undefined) {
                localVarQueryParameter['all'] = all;
            }

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a managed accounts of the logged in user.
         * @param {string} userid 
         * @param {number} year 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingControllerGetOneUser: async (userid: string, year: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('trainingControllerGetOneUser', 'userid', userid)
            // verify required parameter 'year' is not null or undefined
            assertParamExists('trainingControllerGetOneUser', 'year', year)
            const localVarPath = `/training/users/{userid}`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns object of the logged in user
         * @param {number} year 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingControllerGetOwnUser: async (year: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'year' is not null or undefined
            assertParamExists('trainingControllerGetOwnUser', 'year', year)
            const localVarPath = `/training/own`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary gets the values of the personalised view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingControllerGetView: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/training/view`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary stores the values of the personalised view
         * @param {UserView} userView 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingControllerPostView: async (userView: UserView, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userView' is not null or undefined
            assertParamExists('trainingControllerPostView', 'userView', userView)
            const localVarPath = `/training/view`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userView, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload file
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingControllerUploadFile: async (file: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('trainingControllerUploadFile', 'file', file)
            const localVarPath = `/training/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrainingPlatformApi - functional programming interface
 * @export
 */
export const TrainingPlatformApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TrainingPlatformApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Adds a new training
         * @param {Training} training 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainingControllerAddTraining(training: Training, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainingControllerAddTraining(training, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes a training
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainingControllerDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainingControllerDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns the file of a training
         * @param {string} trainingid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainingControllerFile(trainingid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainingControllerFile(trainingid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns all managed accounts of the logged in user.
         * @param {string} [manager] returns the users of a specific manager
         * @param {string} [all] return all users
         * @param {number} [year] timespawn of the claims
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainingControllerGetAllUsers(manager?: string, all?: string, year?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainingControllerGetAllUsers(manager, all, year, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a managed accounts of the logged in user.
         * @param {string} userid 
         * @param {number} year 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainingControllerGetOneUser(userid: string, year: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainingControllerGetOneUser(userid, year, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns object of the logged in user
         * @param {number} year 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainingControllerGetOwnUser(year: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainingControllerGetOwnUser(year, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary gets the values of the personalised view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainingControllerGetView(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainingControllerGetView(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary stores the values of the personalised view
         * @param {UserView} userView 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainingControllerPostView(userView: UserView, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainingControllerPostView(userView, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Upload file
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainingControllerUploadFile(file: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainingControllerUploadFile(file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TrainingPlatformApi - factory interface
 * @export
 */
export const TrainingPlatformApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TrainingPlatformApiFp(configuration)
    return {
        /**
         * 
         * @summary Adds a new training
         * @param {Training} training 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingControllerAddTraining(training: Training, options?: any): AxiosPromise<void> {
            return localVarFp.trainingControllerAddTraining(training, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a training
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingControllerDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.trainingControllerDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the file of a training
         * @param {string} trainingid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingControllerFile(trainingid: string, options?: any): AxiosPromise<void> {
            return localVarFp.trainingControllerFile(trainingid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all managed accounts of the logged in user.
         * @param {string} [manager] returns the users of a specific manager
         * @param {string} [all] return all users
         * @param {number} [year] timespawn of the claims
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingControllerGetAllUsers(manager?: string, all?: string, year?: number, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.trainingControllerGetAllUsers(manager, all, year, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a managed accounts of the logged in user.
         * @param {string} userid 
         * @param {number} year 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingControllerGetOneUser(userid: string, year: number, options?: any): AxiosPromise<object> {
            return localVarFp.trainingControllerGetOneUser(userid, year, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns object of the logged in user
         * @param {number} year 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingControllerGetOwnUser(year: number, options?: any): AxiosPromise<object> {
            return localVarFp.trainingControllerGetOwnUser(year, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary gets the values of the personalised view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingControllerGetView(options?: any): AxiosPromise<UserView> {
            return localVarFp.trainingControllerGetView(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary stores the values of the personalised view
         * @param {UserView} userView 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingControllerPostView(userView: UserView, options?: any): AxiosPromise<void> {
            return localVarFp.trainingControllerPostView(userView, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload file
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingControllerUploadFile(file: any, options?: any): AxiosPromise<FileResponse> {
            return localVarFp.trainingControllerUploadFile(file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TrainingPlatformApi - object-oriented interface
 * @export
 * @class TrainingPlatformApi
 * @extends {BaseAPI}
 */
export class TrainingPlatformApi extends BaseAPI {
    /**
     * 
     * @summary Adds a new training
     * @param {Training} training 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingPlatformApi
     */
    public trainingControllerAddTraining(training: Training, options?: AxiosRequestConfig) {
        return TrainingPlatformApiFp(this.configuration).trainingControllerAddTraining(training, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a training
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingPlatformApi
     */
    public trainingControllerDelete(id: string, options?: AxiosRequestConfig) {
        return TrainingPlatformApiFp(this.configuration).trainingControllerDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the file of a training
     * @param {string} trainingid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingPlatformApi
     */
    public trainingControllerFile(trainingid: string, options?: AxiosRequestConfig) {
        return TrainingPlatformApiFp(this.configuration).trainingControllerFile(trainingid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all managed accounts of the logged in user.
     * @param {string} [manager] returns the users of a specific manager
     * @param {string} [all] return all users
     * @param {number} [year] timespawn of the claims
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingPlatformApi
     */
    public trainingControllerGetAllUsers(manager?: string, all?: string, year?: number, options?: AxiosRequestConfig) {
        return TrainingPlatformApiFp(this.configuration).trainingControllerGetAllUsers(manager, all, year, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a managed accounts of the logged in user.
     * @param {string} userid 
     * @param {number} year 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingPlatformApi
     */
    public trainingControllerGetOneUser(userid: string, year: number, options?: AxiosRequestConfig) {
        return TrainingPlatformApiFp(this.configuration).trainingControllerGetOneUser(userid, year, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns object of the logged in user
     * @param {number} year 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingPlatformApi
     */
    public trainingControllerGetOwnUser(year: number, options?: AxiosRequestConfig) {
        return TrainingPlatformApiFp(this.configuration).trainingControllerGetOwnUser(year, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary gets the values of the personalised view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingPlatformApi
     */
    public trainingControllerGetView(options?: AxiosRequestConfig) {
        return TrainingPlatformApiFp(this.configuration).trainingControllerGetView(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary stores the values of the personalised view
     * @param {UserView} userView 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingPlatformApi
     */
    public trainingControllerPostView(userView: UserView, options?: AxiosRequestConfig) {
        return TrainingPlatformApiFp(this.configuration).trainingControllerPostView(userView, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload file
     * @param {any} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingPlatformApi
     */
    public trainingControllerUploadFile(file: any, options?: AxiosRequestConfig) {
        return TrainingPlatformApiFp(this.configuration).trainingControllerUploadFile(file, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserPlatformApi - axios parameter creator
 * @export
 */
export const UserPlatformApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary returns own information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerOwn: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary resolves the username of the did
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerResolve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userControllerResolve', 'id', id)
            const localVarPath = `/user/resolve/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserPlatformApi - functional programming interface
 * @export
 */
export const UserPlatformApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserPlatformApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary returns own information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerOwn(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerOwn(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary resolves the username of the did
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerResolve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerResolve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserPlatformApi - factory interface
 * @export
 */
export const UserPlatformApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserPlatformApiFp(configuration)
    return {
        /**
         * 
         * @summary returns own information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerOwn(options?: any): AxiosPromise<User> {
            return localVarFp.userControllerOwn(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary resolves the username of the did
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerResolve(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.userControllerResolve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserPlatformApi - object-oriented interface
 * @export
 * @class UserPlatformApi
 * @extends {BaseAPI}
 */
export class UserPlatformApi extends BaseAPI {
    /**
     * 
     * @summary returns own information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPlatformApi
     */
    public userControllerOwn(options?: AxiosRequestConfig) {
        return UserPlatformApiFp(this.configuration).userControllerOwn(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary resolves the username of the did
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPlatformApi
     */
    public userControllerResolve(id: string, options?: AxiosRequestConfig) {
        return UserPlatformApiFp(this.configuration).userControllerResolve(id, options).then((request) => request(this.axios, this.basePath));
    }
}


